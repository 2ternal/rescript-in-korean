{"componentChunkName":"component---src-templates-docs-js","path":"/JavaScript-Interop/05-Bind-to-JS-Function","result":{"data":{"site":{"siteMetadata":{"title":"ReScript in Korean","docsLocation":"https://github.com/green-labs/rescript-in-korean/tree/main/content"}},"mdx":{"fields":{"id":"f93c29b1-2800-578c-a424-943c3a02818b","title":"Bind to JS Function","slug":"/JavaScript-Interop/05-Bind-to-JS-Function"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Bind to JS Function\",\n  \"metaTitle\": \"Bind to JS Function\",\n  \"metaDescription\": \"JS interop with functions in ReScript\",\n  \"sourceUrl\": \"https://rescript-lang.org/docs/manual/latest/bind-to-js-function\",\n  \"canonical\": \"https://rescript-lang.org/docs/manual/latest/bind-to-js-function\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Binding a JS function is like binding any other value:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"/* Import nodejs' path.dirname */\\n@bs.module(\\\"path\\\") external dirname: string => string = \\\"dirname\\\"\\nlet root = dirname(\\\"/User/github\\\") // returns \\\"User\\\"\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"var Path = require('path');\\nvar root = Path.dirname('/User/github');\\n\")), mdx(\"p\", null, \"We also expose a few special features, described below.\"), mdx(\"h2\", null, \"Labeled Arguments\"), mdx(\"p\", null, \"ReScript has \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"function.md#labeled-arguments\"\n  }), \"labeled arguments\"), \" (that can also be optional). These work on an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"external\"), \" too! You'd use them to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"fix\"), \" a JS function's unclear usage. Assuming we're modeling this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// MyGame.js\\n\\nfunction draw(x, y, border) {\\n  // suppose `border` is optional and defaults to false\\n}\\ndraw(10, 20);\\ndraw(20, 20, true);\\n\")), mdx(\"p\", null, \"It'd be nice if on ReScript's side, we can bind & call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"draw\"), \" while labeling things a bit:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"@bs.module(\\\"MyGame\\\")\\nexternal draw: (~x: int, ~y: int, ~border: bool=?, unit) => unit = \\\"draw\\\"\\n\\ndraw(~x=10, ~y=20, ~border=true, ())\\ndraw(~x=10, ~y=20, ())\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"var MyGame = require('MyGame');\\n\\nMyGame.draw(10, 20, true);\\nMyGame.draw(10, 20, undefined);\\n\")), mdx(\"p\", null, \"We've compiled to the same function, but now the usage is much clearer on the ReScript side thanks to labels!\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Note\"), \": in this particular case, you need a unit, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"()\"), \" after \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"border\"), \", since \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"border\"), \" is an \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"function.md#optional-labeled-arguments\"\n  }), \"optional argument at the last position\"), \". Not having a unit to indicate you've finished applying the function would generate a warning.\"), mdx(\"p\", null, \"Note that you can change the order of labeled arguments on the ReScript side and BuckleScript will ensure that they appear the right way in the JavaScript output:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"@bs.module(\\\"MyGame\\\")\\nexternal draw: (~x: int, ~y: int, ~border: bool=?, unit) => unit = \\\"draw\\\"\\n\\ndraw(~x=10, ~y=20, ())\\ndraw(~y=20, ~x=10, ())\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"var MyGame = require('MyGame');\\n\\nMyGame.draw(10, 20, undefined);\\nMyGame.draw(10, 20, undefined);\\n\")), mdx(\"h2\", null, \"Object Method\"), mdx(\"p\", null, \"Functions attached to a JS objects (other than JS modules) require a special way of binding to them, using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bs.send\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"type document // abstract type for a document object\\n@bs.send external getElementById: (document, string) => Dom.element = \\\"getElementById\\\"\\n@bs.val external doc: document = \\\"document\\\"\\n\\nlet el = getElementById(doc, \\\"myId\\\")\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"var el = document.getElementById('myId');\\n\")), mdx(\"p\", null, \"In a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bs.send\"), \", the object is always the first argument. Actual arguments of the method follow (this is a bit what modern OOP objects are really).\"), mdx(\"h3\", null, \"Chaining\"), mdx(\"p\", null, \"Ever used \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foo().bar().baz()\"), \" chaining (\\\"fluent api\\\") in JS OOP? We can model that in BuckleScript too, through the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"pipe.md\"\n  }), \"pipe operator\"), \".\"), mdx(\"h2\", null, \"Variadic Function Arguments\"), mdx(\"p\", null, \"You might have JS functions that take an arbitrary amount of arguments. BuckleScript supports modeling those, under the condition that the arbitrary arguments part is homogenous (aka of the same type). If so, add \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bs.variadic\"), \" to your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"external\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"@bs.module(\\\"path\\\") @bs.variadic\\nexternal join: array<string> => string = \\\"join\\\"\\n\\nlet v = join([\\\"a\\\", \\\"b\\\"])\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"var Path = require('path');\\nvar v = Path.join('a', 'b');\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bs.module\"), \" will be explained in \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"import-from-export-to-js.md\"\n  }), \"Import from/Export to JS\"), \".\"), mdx(\"h2\", null, \"Modeling Polymorphic Function\"), mdx(\"p\", null, \"Apart from the above special-case, JS function in general are often arbitrary overloaded in terms of argument types and number. How would you bind to those?\"), mdx(\"h3\", null, \"Trick 1: Multiple externals\"), mdx(\"p\", null, \"If you can exhaustively enumerate the many forms an overloaded JS function can take, simply bind to each differently:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"@bs.module(\\\"MyGame\\\") external drawCat: unit => unit = \\\"draw\\\"\\n@bs.module(\\\"MyGame\\\") external drawDog: (~giveName: string) => unit = \\\"draw\\\"\\n@bs.module(\\\"MyGame\\\") external draw: (string, ~useRandomAnimal: bool) => unit = \\\"draw\\\"\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Empty output\\n\")), mdx(\"p\", null, \"Note how all three externals bind to the same JS function, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"draw\"), \".\"), mdx(\"h3\", null, \"Trick 2: Polymorphic Variant + bs.unwrap\"), mdx(\"p\", null, \"If you have the irresistible urge of saying \\\"if only this JS function argument was a variant instead of informally being either \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"string\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"int\"), \"\\\", then good news: we do provide such \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"external\"), \" features through annotating a parameter as a polymorphic variant! Assuming you have the following JS function you'd like to bind to:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"function padLeft(value, padding) {\\n  if (typeof padding === 'number') {\\n    return Array(padding + 1).join(' ') + value;\\n  }\\n  if (typeof padding === 'string') {\\n    return padding + value;\\n  }\\n  throw new Error(`Expected string or number, got '${padding}'.`);\\n}\\n\")), mdx(\"p\", null, \"Here, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"padding\"), \" is really conceptually a variant. Let's model it as such.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"@bs.val\\nexternal padLeft: (\\n  string,\\n  @bs.unwrap [\\n    | #Str(string)\\n    | #Int(int)\\n  ])\\n  => string = \\\"padLeft\\\"\\npadLeft(\\\"Hello World\\\", #Int(4))\\npadLeft(\\\"Hello World\\\", #Str(\\\"Message from ReScript: \\\"))\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"padLeft('Hello World', 4);\\npadLeft('Hello World', 'Message from ReScript: ');\\n\")), mdx(\"p\", null, \"Obviously, the JS side couldn't have an argument that's a polymorphic variant! But here, we're just piggy backing on poly variants' type checking and syntax. The secret is the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@bs.unwrap\"), \" annotation on the type. It strips the variant constructors and compile to just the payload's value. See the output.\"), mdx(\"h2\", null, \"Constrain Arguments Better\"), mdx(\"p\", null, \"Consider the Node \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fs.readFileSync\"), \"'s second argument. It can take a string, but really only a defined set: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\"ascii\\\"\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\"utf8\\\"\"), \", etc. You can still bind it as a string, but we can use poly variants + \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bs.string\"), \" to ensure that our usage's more correct:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"@bs.module(\\\"fs\\\")\\nexternal readFileSync: (\\n  ~name: string,\\n  @bs.string [\\n    | #utf8\\n    | @bs.as(\\\"ascii\\\") #useAscii\\n  ],\\n) => string = \\\"readFileSync\\\"\\n\\nreadFileSync(~name=\\\"xx.txt\\\", #useAscii)\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"var Fs = require('fs');\\nFs.readFileSync('xx.txt', 'ascii');\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Attaching \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"@bs.string\"), \" to the whole poly variant type makes its constructor compile to a string of the same name.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Attaching a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"@bs.as(\\\"bla\\\")\"), \" to a constructor lets you customize the final string.\")), mdx(\"p\", null, \"And now, passing something like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\"myOwnUnicode\\\"\"), \" or other variant constructor names to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"readFileSync\"), \" would correctly error.\"), mdx(\"p\", null, \"Aside from string, you can also compile an argument to an int, using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bs.int\"), \" instead of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bs.string\"), \" in a similar way:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"@bs.val\\nexternal testIntType: (\\n  @bs.int [\\n    | #onClosed\\n    | @bs.as(20) #onOpen\\n    | #inBinary\\n  ])\\n  => int = \\\"testIntType\\\"\\ntestIntType(#inBinary)\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"testIntType(21);\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onClosed\"), \" compiles to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onOpen\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"20\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"inBinary\"), \" to \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"21\")), \".\"), mdx(\"h2\", null, \"Special-case: Event Listeners\"), mdx(\"p\", null, \"One last trick with polymorphic variants:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"type readline\\n\\n@bs.send\\nexternal on: (\\n    readline,\\n    @bs.string [\\n      | #close(unit => unit)\\n      | #line(string => unit)\\n    ]\\n  )\\n  => readline = \\\"on\\\"\\n\\nlet register = rl =>\\n  rl\\n  ->on(#close(event => ()))\\n  ->on(#line(line => Js.log(line)));\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"function register(rl) {\\n  return rl\\n    .on('close', function($$event) {})\\n    .on('line', function(line) {\\n      console.log(line);\\n    });\\n}\\n\")), mdx(\"h2\", null, \"Fixed Arguments\"), mdx(\"p\", null, \"Sometimes it's convenient to bind to a function using an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"external\"), \", while passing predetermined argument values to the JS function:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"@bs.val\\nexternal processOnExit: (\\n  @bs.as(\\\"exit\\\") _,\\n  int => unit\\n) => unit = \\\"process.on\\\"\\n\\nprocessOnExit(exitCode =>\\n  Js.log(\\\"error code: \\\" ++ Js.Int.toString(exitCode))\\n);\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"process.on('exit', function(exitCode) {\\n  console.log('error code: ' + exitCode.toString());\\n});\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@bs.as(\\\"exit\\\")\"), \" and the placeholder \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_\"), \" argument together indicates that you want the first argument to compile to the string \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\"exit\\\"\"), \". You can also use any JSON literal with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bs.as\"), \": \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@bs.as(json`true`)\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@bs.as(json`{\\\"name\\\": \\\"John\\\"}`)\"), \", etc.\"), mdx(\"h2\", null, \"Curry & Uncurry\"), mdx(\"p\", null, \"Curry is a delicious Indian dish. More importantly, in the context of ReScript (and functional programming in general), currying means that function taking multiple arguments can be applied a few arguments at time, until all the arguments are applied.\"), mdx(\"p\", null, \"See the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"addFive\"), \" intermediate function? \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"add\"), \" takes in 3 arguments but received only 1. It's interpreted as \\\"currying\\\" the argument \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"5\"), \" and waiting for the next 2 arguments to be applied later on. Type signatures:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-res\",\n    \"metastring\": \"sig\",\n    \"sig\": true\n  }), \"let add: (int, int, int) => int\\nlet addFive: (int, int) => int\\nlet twelve: int\\n\")), mdx(\"p\", null, \"(In a dynamic language such as JS, currying would be dangerous, since accidentally forgetting to pass an argument doesn't error at compile time).\"), mdx(\"h3\", null, \"Drawback\"), mdx(\"p\", null, \"Unfortunately, due to JS not having currying because of the aforementioned reason, it's hard for ReScript multi-argument functions to map cleanly to JS functions 100% of the time:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"When all the arguments of a function are supplied (aka no currying), ReScript does its best to to compile e.g. a 3-arguments call into a plain JS call with 3 arguments.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"If it's too hard to detect whether a function application is complete\", \"*\", \", ReScript will use a runtime mechanism (the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Curry\"), \" module) to curry as many args as we can and check whether the result is fully applied.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Some JS APIs like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"throttle\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"debounce\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"promise\"), \" might mess with context, aka use the function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bind\"), \" mechanism, carry around \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \", etc. Such implementation clashes with the previous currying logic.\"))), mdx(\"p\", null, \"*\", \" If the call site is typed as having 3 arguments, we sometimes don't know whether it's a function that's being curried, or if the original one indeed has only 3 arguments.\"), mdx(\"p\", null, \"ReScript tries to do #1 as much as it can. Even when it bails and uses #2's currying mechanism, it's usually harmless.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"However\"), \", if you encounter #3, heuristics are not good enough: you need a guaranteed way of fully applying a function, without intermediate currying steps. We provide such guarantee through the use of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@bs\"), \" \\\"uncurrying\\\" annotation on a function declaration & call site.\"), mdx(\"h3\", null, \"Solution: Use Guaranteed Uncurrying\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"function.md#uncurried-function\"\n  }), \"Uncurried function\"), \" annotation also works on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"external\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"type timerId\\n@bs.val external setTimeout: ((. unit) => unit, int) => timerId = \\\"setTimeout\\\"\\n\\nlet id = setTimeout((.) => Js.log(\\\"hello\\\"), 1000)\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"var id = setTimeout(function() {\\n  console.log('hello');\\n}, 1000);\\n\")), mdx(\"h4\", null, \"Extra Solution\"), mdx(\"p\", null, \"The above solution is safe, guaranteed, and performant, but sometimes visually a little burdensome. We provide an alternative solution if:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"you're using \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"external\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"external\"), \" function takes in an argument that's another function\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"you want the user \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"not\"), \" to need to annotate the call sites with the dot\")), mdx(\"p\", null, \"Then try \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@bs.uncurry\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"@bs.send external map: (array<'a>, @bs.uncurry ('a => 'b)) => array<'b> = \\\"map\\\"\\nmap([1, 2, 3], x => x + 1)\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Empty output\\n\")), mdx(\"p\", null, \"In general, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bs.uncurry\"), \" is recommended; the compiler will do lots of optimizations to resolve the currying to uncurrying at compile time. However, there are some cases the compiler can't optimize it. In these cases, it will be converted to a runtime check.\"), mdx(\"h2\", null, \"Modeling this-based Callbacks\"), mdx(\"p\", null, \"Many JS libraries have callbacks which rely on this (the source), for example:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"x.onload = function(v) {\\n  console.log(this.response + v);\\n};\\n\")), mdx(\"p\", null, \"Here, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \" would point to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" (actually, it depends on how \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onload\"), \" is called, but we digress). It's not correct to declare \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x.onload\"), \" of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(. unit) -> unit\"), \". Instead, we introduced a special attribute, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bs.this\"), \", which allows us to type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" as so:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"type x\\n@bs.val external x: x = \\\"x\\\"\\n@bs.set external setOnload: (x, @bs.this ((x, int) => unit)) => unit = \\\"onload\\\"\\n@bs.get external resp: x => int = \\\"response\\\"\\nsetOnload(x, @bs.this ((o, v) => Js.log(resp(o) + v)))\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"x.onload = function(v) {\\n  var o = this;\\n  console.log((o.response + v) | 0);\\n};\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bs.this\"), \" has its first parameter is reserved for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \" and for arity of 0, there is no need for a redundant \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"unit\"), \" type.\"), mdx(\"h2\", null, \"Function Nullable Return Value Wrapping\"), mdx(\"p\", null, \"For JS functions that return a value that can also be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"null\"), \", we provide \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@bs.return(...)\"), \". To automatically convert that value to an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"option\"), \" type (recall that ReScript \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"option\"), \" type's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"None\"), \" value only compiles to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined\"), \" and not \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"null\"), \").\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"type element\\ntype dom\\n\\n@bs.send @bs.return(nullable)\\nexternal getElementById: (dom, string) => option<element> = \\\"getElementById\\\"\\n\\nlet test = dom => {\\n  let elem = dom->(getElementById(\\\"haha\\\"))\\n  switch (elem) {\\n  | None => 1\\n  | Some(_ui) => 2\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"function test(dom) {\\n  var elem = dom.getElementById('haha');\\n  if (elem == null) {\\n    return 1;\\n  } else {\\n    console.log(elem);\\n    return 2;\\n  }\\n}\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bs.return(nullable)\"), \" attribute will automatically convert \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"null\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"option\"), \" type.\"), mdx(\"p\", null, \"Currently 4 directives are supported: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"null_to_opt\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined_to_opt\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nullable\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"identity\"), \".\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"identity\"), \" will make sure that compiler will do nothing about the returned value. It is rarely used, but introduced here for debugging purpose.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#labeled-arguments","title":"Labeled Arguments"},{"url":"#object-method","title":"Object Method","items":[{"url":"#chaining","title":"Chaining"}]},{"url":"#variadic-function-arguments","title":"Variadic Function Arguments"},{"url":"#modeling-polymorphic-function","title":"Modeling Polymorphic Function","items":[{"url":"#trick-1-multiple-externals","title":"Trick 1: Multiple externals"},{"url":"#trick-2-polymorphic-variant--bsunwrap","title":"Trick 2: Polymorphic Variant + bs.unwrap"}]},{"url":"#constrain-arguments-better","title":"Constrain Arguments Better"},{"url":"#special-case-event-listeners","title":"Special-case: Event Listeners"},{"url":"#fixed-arguments","title":"Fixed Arguments"},{"url":"#curry--uncurry","title":"Curry & Uncurry","items":[{"url":"#drawback","title":"Drawback"},{"url":"#solution-use-guaranteed-uncurrying","title":"Solution: Use Guaranteed Uncurrying","items":[{"url":"#extra-solution","title":"Extra Solution"}]}]},{"url":"#modeling-this-based-callbacks","title":"Modeling this-based Callbacks"},{"url":"#function-nullable-return-value-wrapping","title":"Function Nullable Return Value Wrapping"}]},"parent":{"__typename":"File","relativePath":"JavaScript-Interop/05-Bind-to-JS-Function.mdx"},"frontmatter":{"metaTitle":"Bind to JS Function","metaDescription":"JS interop with functions in ReScript","sourceUrl":"https://rescript-lang.org/docs/manual/latest/bind-to-js-function","canonical":"https://rescript-lang.org/docs/manual/latest/bind-to-js-function"}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/Build-System","title":"Build System"}}},{"node":{"fields":{"slug":"/Guides","title":"Guides"}}},{"node":{"fields":{"slug":"/Extra","title":"Extra"}}},{"node":{"fields":{"slug":"/JavaScript-Interop","title":"JavaScript Interop"}}},{"node":{"fields":{"slug":"/Language-Features","title":"Language Features"}}},{"node":{"fields":{"slug":"/Overview","title":"Overview"}}},{"node":{"fields":{"slug":"/","title":"ReScript in Korean"}}},{"node":{"fields":{"slug":"/Build-System/01-Overview","title":"Build System Overview"}}},{"node":{"fields":{"slug":"/Build-System/02-Configuration","title":"Configuration"}}},{"node":{"fields":{"slug":"/Build-System/03-Configuration-Schema","title":"Configuration Schema"}}},{"node":{"fields":{"slug":"/Build-System/04-Interop-with-JS-Build-Systems","title":"Interop with JS Build Systems"}}},{"node":{"fields":{"slug":"/Build-System/05-Performance","title":"Performance"}}},{"node":{"fields":{"slug":"/Extra/01-Newcomer-Examples","title":"초보자를 위한 예제"}}},{"node":{"fields":{"slug":"/Extra/02-Project-Structure","title":"Project Structure"}}},{"node":{"fields":{"slug":"/Extra/03-FAQ","title":"자주 묻는 질문"}}},{"node":{"fields":{"slug":"/Guides/01-Converting-from-JS","title":"자바스크립트 파일을 변환하기"}}},{"node":{"fields":{"slug":"/Guides/02-Libraries","title":"Libraries"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/01-Embed-Raw-JavaScript","title":"Embed Raw JavaScript"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/02-Shared-Data-Types","title":"Shared Data Types"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/03-External-Bind-to-Any-JS-Library","title":"External (자바스크립트 라이브러리 바인딩)"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/04-Bind-to-JS-Object","title":"자바스크립트 객체에 바인딩하기."}}},{"node":{"fields":{"slug":"/JavaScript-Interop/05-Bind-to-JS-Function","title":"Bind to JS Function"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/06-Import-from-Export-to-JS","title":"Import from / Export to JS"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/07-Bind-to-Global-JS-Values","title":"Bind to Global JS Values"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/08-JSON","title":"JSON"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/09-Inlining-Constants","title":"Inlining Constants"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/10-Use-Illegal-Identifier-Names","title":"Use Illegal Identifier Names"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/11-Generate-Converters-Helpers","title":"Generate Converters & Helpers"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/12-Browser-Support-Polyfills","title":"Browser Support & Polyfills"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/13-Interop-Cheatsheet","title":"Interop Cheatsheet"}}},{"node":{"fields":{"slug":"/Language-Features/01-Overview","title":"개요"}}},{"node":{"fields":{"slug":"/Language-Features/02-Let-Binding","title":"Let Binding"}}},{"node":{"fields":{"slug":"/Language-Features/03-Type","title":"타입"}}},{"node":{"fields":{"slug":"/Language-Features/04-Primitive-Types","title":"원시 타입"}}},{"node":{"fields":{"slug":"/Language-Features/05-Tuple","title":"튜플"}}},{"node":{"fields":{"slug":"/Language-Features/06-Record","title":"레코드"}}},{"node":{"fields":{"slug":"/Language-Features/07-Object","title":"객체"}}},{"node":{"fields":{"slug":"/Language-Features/08-Variant","title":"배리언트"}}},{"node":{"fields":{"slug":"/Language-Features/09-Polymorphic-Variant","title":"Polymorphic Variant"}}},{"node":{"fields":{"slug":"/Language-Features/10-Null-Undefined-and-Option","title":"Null, Undefined 그리고 Option"}}},{"node":{"fields":{"slug":"/Language-Features/11-Array-List","title":"배열과 리스트"}}},{"node":{"fields":{"slug":"/Language-Features/12-Function","title":"함수"}}},{"node":{"fields":{"slug":"/Language-Features/13-Control-Flow","title":"제어 흐름"}}},{"node":{"fields":{"slug":"/Language-Features/14-Pipe","title":"파이프"}}},{"node":{"fields":{"slug":"/Language-Features/15-Pattern-Matching-Destructuring","title":"패턴 매칭 / 구조분해"}}},{"node":{"fields":{"slug":"/Language-Features/16-Mutation","title":"가변"}}},{"node":{"fields":{"slug":"/Language-Features/17-JSX","title":"JSX"}}},{"node":{"fields":{"slug":"/Language-Features/18-Exception","title":"예외"}}},{"node":{"fields":{"slug":"/Language-Features/19-Lazy-Value","title":"Lazy Value"}}},{"node":{"fields":{"slug":"/Language-Features/20-Async-Promise","title":"Async & Promise"}}},{"node":{"fields":{"slug":"/Language-Features/21-Module","title":"모듈"}}},{"node":{"fields":{"slug":"/Language-Features/22-Import-Export","title":"Import & Export"}}},{"node":{"fields":{"slug":"/Language-Features/23-Attribute-Decorator","title":"속성 (데코레이터)"}}},{"node":{"fields":{"slug":"/Language-Features/24-Unboxed","title":"언박싱"}}},{"node":{"fields":{"slug":"/Language-Features/25-Reserved-Keyword","title":"예약된 키워드"}}},{"node":{"fields":{"slug":"/Overview/01-Introduction","title":"소개"}}},{"node":{"fields":{"slug":"/Overview/02-Installation","title":"설치"}}},{"node":{"fields":{"slug":"/Overview/03-EditorPlugins","title":"편집기 플러그인"}}},{"node":{"fields":{"slug":"/Overview/04-Migrate-to-ReScript-Syntax","title":"리스크립트 문법으로 변경하기"}}},{"node":{"fields":{"slug":"/Overview/05-Try","title":"CLI로 직접 해보기"}}}]}},"pageContext":{"id":"f93c29b1-2800-578c-a424-943c3a02818b"}},"staticQueryHashes":["2619113677","2619113677","3706406642","3706406642","417421954","417421954"]}