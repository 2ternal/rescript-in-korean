{"componentChunkName":"component---src-templates-docs-js","path":"/ReScript-React/02-Main-Concepts/03-Components-and-Props","result":{"data":{"site":{"siteMetadata":{"title":"ReScript in Korean","docsLocation":"https://github.com/green-labs/rescript-in-korean/tree/main/content"}},"mdx":{"fields":{"id":"875788f8-b9b5-5bd6-975d-88f012e1f214","title":"컴포넌트와 Props","slug":"/ReScript-React/02-Main-Concepts/03-Components-and-Props"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"컴포넌트와 Props\",\n  \"metaTitle\": \"03-컴포넌트와 Props(Components and Props)\",\n  \"metaDescription\": \"Basic concepts for components and props in ReScript & React\",\n  \"canonical\": \"https://rescript-lang.org/docs/react/latest/components-and-props\",\n  \"sourceUrl\": \"https://rescript-lang.org/docs/react/latest/components-and-props\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Components let you split the UI into independent, reusable pieces, and think about each piece in isolation. This page provides an introduction to the idea of components.\"), mdx(\"h2\", null, \"What is a Component?\"), mdx(\"p\", null, \"A React component is a function describing a UI element that receives a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"props\"), \" object as a parameter (data describing the dynamic parts of the UI) and returns a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.element\"), \".\"), mdx(\"p\", null, \"The nice thing about this concept is that you can solely focus on the input and output. The component function receives some data and returns some opaque \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.element\"), \" that is managed by the React framework to render your UI.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"If you want to know more about the low level details on how a component interface is implemented, refer to the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./beyond-jsx\"\n  }, \"Beyond JSX\"), \" page.\")), mdx(\"h2\", null, \"Component Example\"), mdx(\"p\", null, \"Let's start with a first example to see how a ReScript React component looks like:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-reason\"\n  }, \"// src/Greeting.res\\n@react.component\\nlet make = () => {\\n  <div>\\n    {React.string(\\\"Hello ReScripters!\\\")}\\n  </div>\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"var React = require('react');\\n\\nfunction Greeting(Props) {\\n  return React.createElement('div', undefined, 'Hello ReScripters!');\\n}\\n\\nvar make = Greeting;\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Important:\"), \" Always make sure to name your component function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"make\"), \" and don't forget to add the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@react.component\"), \" attribute.\"), mdx(\"p\", null, \"We've created a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Greeting.res\"), \" file that contains a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"make\"), \" function that doesn't receive any props (the function doesn't receive any parameters), and returns a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.element\"), \" that represents \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<div> Hello ReScripters! </div>\"), \" in the rendered DOM.\"), mdx(\"p\", null, \"You can also see in the the JS output that the function we created was directly translated into the pure JS version of a ReactJS component. Note how a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<div>\"), \" transforms into a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.createElement(\\\"div\\\",...)\"), \" call in JavaScript.\"), mdx(\"h2\", null, \"Defining Props\"), mdx(\"p\", null, \"In ReactJS, props are usually described as a single \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"props\"), \" object. In ReScript, we use \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rescript-in-korean/docs/manual/latest/function#labeled-arguments\"\n  }, \"labeled arguments\"), \" to define our props parameters instead. Here's an example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-reason\"\n  }, \"// src/Article.res\\n@react.component\\nlet make = (~title: string, ~visitorCount: int, ~children: React.element) => {\\n  let visitorCountMsg = \\\"You are visitor number: \\\" ++ Belt.Int.toString(visitorCount);\\n  <div>\\n    <div> {React.string(title)} </div>\\n    <div> {React.string(vistorCount)} </div>\\n    children\\n  </div>\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"var React = require('react');\\n\\nfunction Article(Props) {\\n  var title = Props.title;\\n  var visitorCount = Props.visitorCount;\\n  var children = Props.children;\\n  var visitorCountMsg = 'You are visitor number: ' + String(visitorCount);\\n  return React.createElement(\\n    'div',\\n    undefined,\\n    React.createElement('div', undefined, title),\\n    React.createElement('div', undefined, visitorCountMsg),\\n    children\\n  );\\n}\\n\\nvar make = Article;\\n\")), mdx(\"h3\", null, \"Optional Props\"), mdx(\"p\", null, \"We can leverage the full power of labeled arguments to define optional props as well:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-reason\"\n  }, \"// Greeting.res\\n@react.component\\nlet make = (~name: option<string>=?) => {\\n  let greeting = switch name {\\n    | Some(name) => \\\"Hello \\\" ++ name ++ \\\"!\\\"\\n    | None => \\\"Hello stranger!\\\"\\n  }\\n  <div> {React.string(greeting)} </div>\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function Greeting(Props) {\\n  var name = Props.name;\\n  var greeting = name !== undefined ? 'Hello ' + name + '!' : 'Hello stranger!';\\n  return React.createElement('div', undefined, greeting);\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"\\uCC38\\uACE0\"), \" The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@react.component\"), \" attribute implicitly adds the last \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"()\"), \" parameter to our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"make\"), \" function for us (no need to do it ourselves).\"), mdx(\"p\", null, \"In JSX, you can apply optional props with some special syntax:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-reason\"\n  }, \"let name = Some(\\\"Andrea\\\")\\n\\n<Greeting ?name />\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"var Caml_option = require('./stdlib/caml_option.js');\\nvar name = 'Andrea';\\n\\nvar tmp = {};\\n\\nif (name !== undefined) {\\n  tmp.name = Caml_option.valFromOption(name);\\n}\\n\\nvar greeting = React.createElement(Playground$Greeting, tmp);\\n\")), mdx(\"h3\", null, \"Special Props key and ref\"), mdx(\"p\", null, \"You can't define any props called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"key\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ref\"), \". React treats those props differently and the compiler will will yield an error whenever you try to define a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"~key\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"~ref\"), \" argument in your component function.\"), mdx(\"p\", null, \"Check out the corresponding \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./arrays-and-keys\"\n  }, \"Arrays and Keys\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./forwarding-refs\"\n  }, \"Forwarding React Refs\"), \" sections for more details.\"), mdx(\"h3\", null, \"Handling Invalid Prop Names (e.g. keywords)\"), mdx(\"p\", null, \"Prop names like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"type\"), \" (as in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<input type=\\\"text\\\" />\"), \") aren't syntactically valid; \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"type\"), \" is a reserved keyword in ReScript. Use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<input type_=\\\"text\\\" />\"), \" instead.\"), mdx(\"p\", null, \"For \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"aria-*\"), \" use camelCasing, e.g., \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ariaLabel\"), \". For DOM components, we'll translate it to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"aria-label\"), \" under the hood.\"), mdx(\"p\", null, \"For \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"data-*\"), \" this is a bit trickier; words with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"-\"), \" in them aren't valid in ReScript. When you do want to write them, e.g., \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<div data-name=\\\"click me\\\" />\"), \", check out the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./rendering-elements#cloning-elements\"\n  }, \"React.cloneElement\"), \" or \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./rendering-elements#creating-dom-elements\"\n  }, \"React.createDOMElementVariadic\"), \" section.\"), mdx(\"h2\", null, \"Children Props\"), mdx(\"p\", null, \"In React \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"props.children\"), \" is a special attribute to represent the nested elements within a parent element:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-reason\"\n  }, \"let element = <div> child1 child2 </div>\\n\")), mdx(\"p\", null, \"By default, whenever you are passing children like in the expression above, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"children\"), \" will be treated\\nas a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.element\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-reason\"\n  }, \"module MyList = {\\n  @react.component\\n  let make = (~children: React.element) => {\\n    <ul>\\n      children\\n    </ul>\\n  }\\n}\\n\\n<MyList>\\n  <li> {React.string(\\\"Item 1\\\")} </li>\\n  <li> {React.string(\\\"Item 2\\\")} </li>\\n</MyList>\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function MyList(Props) {\\n  var children = Props.children;\\n  return React.createElement('ul', undefined, children);\\n}\\n\\nvar MyList = {\\n  make: MyList,\\n};\\n\\nReact.createElement(\\n  MyList,\\n  {\\n    children: null,\\n  },\\n  React.createElement('li', undefined, 'Item 1'),\\n  React.createElement('li', undefined, 'Item 2')\\n);\\n\")), mdx(\"p\", null, \"Interestingly, it doesn't matter if you are passing just one element, or several, React will always collapse its children to a single \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.element\"), \".\"), mdx(\"p\", null, \"It is also possible to redefine the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"children\"), \" type as well. Here are some examples:\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Component with a mandatory \", mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"string\"), \" as children:\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-reason\"\n  }, \"module StringChildren = {\\n  @react.component\\n  let make = (~children: string) => {\\n    <div>\\n      {React.string(children)}\\n    </div>\\n  }\\n}\\n\\n<StringChildren> \\\"My Child\\\" </StringChildren>\\n\\n// This will cause a type check error\\n<StringChildren/>\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Component with an optional \", mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"React.element\"), \" as children:\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-reason\"\n  }, \"module OptionalChildren = {\\n  @react.component\\n  let make = (~children: option<React.element>=?) => {\\n    <div>\\n      {switch children {\\n      | Some(element) => element\\n      | None => React.string(\\\"No children provided\\\")\\n      }}\\n    </div>\\n  }\\n}\\n\\n<div>\\n  <OptionalChildren />\\n  <OptionalChildren> <div /> </OptionalChildren>\\n</div>\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Component that doesn't allow children at all:\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-reason\"\n  }, \"module NoChildren = {\\n  @react.component\\n  let make = () => {\\n    <div>\\n      {React.string(\\\"I don't accept any children params\\\")}\\n    </div>\\n  }\\n}\\n\\n// The compiler will raise a type error here\\n<NoChildren> <div/> </NoChildren>\\n\")), mdx(\"p\", null, \"Children props are really tempting to be abused as a way to model hierarchies, e.g. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<List> <ListHeader/> <Item/> </List>\"), \" (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"List\"), \" should only allow \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Item\"), \" / \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ListHeader\"), \" elements), but this kind of constraint is hard to enforce because all components end up being a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.element\"), \", so it would require notorious runtime checking within \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"List\"), \" to verify that all children are in fact of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Item\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ListHeader\"), \".\"), mdx(\"p\", null, \"The best way to approach this kind of issue is by using props instead of children, e.g. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<List header=\\\"...\\\" items=[{id: \\\"...\\\", text: \\\"...\\\"}]/>\"), \". This way it's easy to type check the constraints, and it also spares component consumers from memorizing and remembering component constraints.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"The best use-case for \", mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"children\"), \" is to pass down \", mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"React.element\"), \"s without any semantic order or implementation details!\")), mdx(\"h2\", null, \"Props & Type Inference\"), mdx(\"p\", null, \"The ReScript type system is really good at inferring the prop types just by looking at its prop usage.\"), mdx(\"p\", null, \"For simple cases, well-scoped usage, or experimentation, it's still fine to omit type annotations:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-reason\"\n  }, \"// Button.res\\n\\n@react.component\\nlet make = (~onClick, ~msg, ~children) => {\\n  <div onClick>\\n    {React.string(msg)}\\n    children\\n  </div>\\n}\\n\")), mdx(\"p\", null, \"In the example above, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onClick\"), \" will be inferred as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ReactEvent.Mouse.t => unit\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"msg\"), \" as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"string\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"children\"), \" as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.element\"), \". Type inference is especially useful when you just forward values to some smaller (privately scoped) functions.\"), mdx(\"p\", null, \"Even tough type inference spares us a lot of keyboard typing, we still recommend to explicitly type your props (just like with any public API) for better type visibility and to prevent confusing type errors.\"), mdx(\"h2\", null, \"Using Components in JSX\"), mdx(\"p\", null, \"Every ReScript component can be used in JSX. For example, if we want to use our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Greeting\"), \" component within our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App\"), \" component, we can do this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-reason\"\n  }, \"// src/App.re\\n\\n@react.component\\nlet make = () => {\\n  <div>\\n    <Greeting/>\\n  </div>\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"var React = require('react');\\nvar Greeting = require('./Greeting.js');\\n\\nfunction App(Props) {\\n  return React.createElement('div', undefined, React.createElement(Greeting.make, {}));\\n}\\n\\nvar make = App;\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"\\uCC38\\uACE0\"), \" React components are capitalized; primitive DOM elements like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"div\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"button\"), \" are uncapitalized. More infos on the JSX specifics and code transformations can be found in our \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/rescript-in-korean/docs/manual/latest/jsx#capitalized-tag\"\n  }, \"JSX language manual section\"), \".\"), mdx(\"h3\", null, \"Handwritten Components\"), mdx(\"p\", null, \"You don't need to use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@react.component\"), \" decorator to write components that can be used in JSX. Instead you can write a pair of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"make\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"makeProps\"), \" functions such that type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"makeProps: 'a => props\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"make: props => React.element\"), \" and these will always work as React components.\"), mdx(\"p\", null, \"This works with your own version of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@obj\"), \", or any other function that takes named args and returns a single props structure. For example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-reason\"\n  }, \"module Link = {\\n  type props = {\\\"href\\\": string, \\\"children\\\": React.element};\\n  @obj external makeProps:(\\n    ~href: string,\\n    ~children: React.element,\\n    unit) => props = \\\"\\\"\\n\\n  let make = (props: props) => {\\n    <a href={props[\\\"href\\\"]}>\\n     {props[\\\"children\\\"]}\\n    </a>\\n  }\\n}\\n\\n<Link href=\\\"/docs\\\"> {React.string(\\\"Docs\\\")} </Link>\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function Link(props) {\\n  return React.createElement(\\n    'a',\\n    {\\n      href: props.href,\\n    },\\n    props.children\\n  );\\n}\\n\\nReact.createElement(Link, {\\n  href: '/docs',\\n  children: 'Docs',\\n});\\n\")), mdx(\"p\", null, \"More details on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@react.component\"), \" decorator and its generated interface can be found in our \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./beyond-jsx\"\n  }, \"Beyond JSX\"), \" page.\"), mdx(\"h2\", null, \"Submodule Components\"), mdx(\"p\", null, \"We can also represent React components as submodules, which makes it very convenient to build more complex UI without the need to create multiple files for each composite component (that's probably only used by the parent component anyways):\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-reason\"\n  }, \"// src/Button.res\\nmodule Label = {\\n  @react.component\\n  let make = (~title: string) => {\\n    <div className=\\\"myLabel\\\"> {React.string(title)} </div>\\n  }\\n}\\n\\n@react.component\\nlet make = (~children) => {\\n  <div>\\n    <Label title=\\\"Getting Started\\\" />\\n    children\\n  </div>\\n}\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Button.res\"), \" file defined above is now containing a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Label\"), \" component, that can also be used by other components, either by writing the fully qualified module name (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<Button.Label title=\\\"My Button\\\"/>\"), \") or by using a module alias to shortcut the full qualifier:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-reason\"\n  }, \"module Label = Button.Label\\n\\nlet content = <Label title=\\\"Test\\\"/>\\n\")), mdx(\"h2\", null, \"Component Naming\"), mdx(\"p\", null, \"Because components are actually a pair of functions, they have to belong to a module to be used in JSX. It makes sense to use these modules for identification purposes as well. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@react.component\"), \" automatically adds the name for you based on the module you are in.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-reason\"\n  }, \"// File.res\\n\\n// will be named `File` in dev tools\\n@react.component\\nlet make = ...\\n\\n// will be named `File$component` in dev tools\\n@react.component\\nlet component = ...\\n\\nmodule Nested = {\\n  // will be named `File$Nested` in dev tools\\n  @react.component\\n  let make = ...\\n};\\n\")), mdx(\"p\", null, \"If you need a dynamic name for higher-order components or you would like to set your own name you can use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.setDisplayName(make, \\\"NameThatShouldBeInDevTools\\\")\"), \".\"), mdx(\"h2\", null, \"Tips & Tricks\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Start with one component file and utilize submodule components as your component grows. Consider splitting up in multiple files when really necessary.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Keep your directory hierarchy flat. Instead of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"article/Header.res\"), \" use \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ArticleHeader.res\"), \" etc. Filenames are unique across the codebase, so filenames tend to be very specific \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ArticleUserHeaderCard.res\"), \", which is not necessarily a bad thing, since it clearly expresses the intent of the component within its name, and makes it also very easy to find, match and refactor across the whole codebase.\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#what-is-a-component","title":"What is a Component?"},{"url":"#component-example","title":"Component Example"},{"url":"#defining-props","title":"Defining Props","items":[{"url":"#optional-props","title":"Optional Props"},{"url":"#special-props-key-and-ref","title":"Special Props key and ref"},{"url":"#handling-invalid-prop-names-eg-keywords","title":"Handling Invalid Prop Names (e.g. keywords)"}]},{"url":"#children-props","title":"Children Props"},{"url":"#props--type-inference","title":"Props & Type Inference"},{"url":"#using-components-in-jsx","title":"Using Components in JSX","items":[{"url":"#handwritten-components","title":"Handwritten Components"}]},{"url":"#submodule-components","title":"Submodule Components"},{"url":"#component-naming","title":"Component Naming"},{"url":"#tips--tricks","title":"Tips & Tricks"}]},"parent":{"__typename":"File","relativePath":"ReScript-React/02-Main-Concepts/03-Components-and-Props.mdx"},"frontmatter":{"metaTitle":"03-컴포넌트와 Props(Components and Props)","metaDescription":"Basic concepts for components and props in ReScript & React","sourceUrl":"https://rescript-lang.org/docs/react/latest/components-and-props","canonical":"https://rescript-lang.org/docs/react/latest/components-and-props"}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/Extra","title":"그 외"}}},{"node":{"fields":{"slug":"/ReScript-React/02-Main-Concepts/02-Rendering-Elements","title":"엘레멘트 렌더링하기"}}},{"node":{"fields":{"slug":"/Guides","title":"가이드"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/04-Bind-to-JS-Object","title":"자바스크립트 객체에 바인딩하기"}}},{"node":{"fields":{"slug":"/Overview","title":"개요"}}},{"node":{"fields":{"slug":"/Language-Features","title":"언어적인 특징"}}},{"node":{"fields":{"slug":"/ReScript-React/02-Main-Concepts","title":"메인 컨셉"}}},{"node":{"fields":{"slug":"/JavaScript-Interop","title":"자바스크립트 인터롭"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management","title":"리액트 훅과 상태 관리"}}},{"node":{"fields":{"slug":"/ReScript-React/01-Overview","title":"개요"}}},{"node":{"fields":{"slug":"/Build-System","title":"빌드 시스템"}}},{"node":{"fields":{"slug":"/ReScript-React","title":"ReScript React"}}},{"node":{"fields":{"slug":"/","title":"ReScript in Korean"}}},{"node":{"fields":{"slug":"/ReScript-React/04-Guides","title":"가이드"}}},{"node":{"fields":{"slug":"/ReScript-React/04-Guides/02-Forwarding-Refs","title":"Ref 포워딩하기"}}},{"node":{"fields":{"slug":"/ReScript-React/04-Guides/01-Beyond-JSX","title":"JSX를 넘어서"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management/01-Hooks-and-State-Management-Overview","title":"리액트 훅과 상태 관리 개요"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management/02-useEffect","title":"useEffect"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management/03-useState","title":"useState"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management/05-useContext","title":"useContext"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management/04-useReducer","title":"useReducer"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management/06-useRef","title":"useRef"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management/07-Build-A-Custom-Hook","title":"커스텀 훅 만들기"}}},{"node":{"fields":{"slug":"/ReScript-React/02-Main-Concepts/04-Arrays-and-Keys","title":"배열과 키"}}},{"node":{"fields":{"slug":"/ReScript-React/02-Main-Concepts/05-Refs-and-the-DOM","title":"Refs와 DOM"}}},{"node":{"fields":{"slug":"/ReScript-React/02-Main-Concepts/03-Components-and-Props","title":"컴포넌트와 Props"}}},{"node":{"fields":{"slug":"/Overview/02-Installation","title":"설치"}}},{"node":{"fields":{"slug":"/Overview/01-Introduction","title":"소개"}}},{"node":{"fields":{"slug":"/ReScript-React/01-Overview/01-Introduction","title":"소개"}}},{"node":{"fields":{"slug":"/ReScript-React/02-Main-Concepts/06-Context","title":"컨텍스트"}}},{"node":{"fields":{"slug":"/ReScript-React/01-Overview/02-Installation","title":"설치"}}},{"node":{"fields":{"slug":"/Overview/03-EditorPlugins","title":"편집기 플러그인"}}},{"node":{"fields":{"slug":"/Language-Features/02-Let-Binding","title":"Let Binding"}}},{"node":{"fields":{"slug":"/Language-Features/01-Overview","title":"개요"}}},{"node":{"fields":{"slug":"/Overview/04-Migrate-to-ReScript-Syntax","title":"리스크립트 문법으로 변경하기"}}},{"node":{"fields":{"slug":"/Language-Features/06-Record","title":"레코드"}}},{"node":{"fields":{"slug":"/Language-Features/03-Type","title":"타입"}}},{"node":{"fields":{"slug":"/Overview/05-Try","title":"CLI로 직접 해보기"}}},{"node":{"fields":{"slug":"/Language-Features/04-Primitive-Types","title":"원시 타입"}}},{"node":{"fields":{"slug":"/Language-Features/10-Null-Undefined-and-Option","title":"Null, Undefined 그리고 Option"}}},{"node":{"fields":{"slug":"/Language-Features/05-Tuple","title":"튜플"}}},{"node":{"fields":{"slug":"/Language-Features/08-Variant","title":"배리언트"}}},{"node":{"fields":{"slug":"/Language-Features/09-Polymorphic-Variant","title":"Polymorphic Variant"}}},{"node":{"fields":{"slug":"/Language-Features/11-Array-List","title":"배열과 리스트"}}},{"node":{"fields":{"slug":"/Language-Features/13-Control-Flow","title":"제어 흐름"}}},{"node":{"fields":{"slug":"/Language-Features/14-Pipe","title":"파이프"}}},{"node":{"fields":{"slug":"/Language-Features/15-Pattern-Matching-Destructuring","title":"패턴 매칭 / 구조분해"}}},{"node":{"fields":{"slug":"/Language-Features/17-JSX","title":"JSX"}}},{"node":{"fields":{"slug":"/Language-Features/16-Mutation","title":"가변"}}},{"node":{"fields":{"slug":"/Language-Features/18-Exception","title":"예외"}}},{"node":{"fields":{"slug":"/Language-Features/12-Function","title":"함수"}}},{"node":{"fields":{"slug":"/Language-Features/20-Async-Promise","title":"Async & Promise"}}},{"node":{"fields":{"slug":"/Language-Features/19-Lazy-Value","title":"Lazy Value"}}},{"node":{"fields":{"slug":"/Language-Features/22-Import-Export","title":"Import & Export"}}},{"node":{"fields":{"slug":"/Language-Features/21-Module","title":"모듈"}}},{"node":{"fields":{"slug":"/Language-Features/23-Attribute-Decorator","title":"속성 (데코레이터)"}}},{"node":{"fields":{"slug":"/Language-Features/25-Reserved-Keyword","title":"예약된 키워드"}}},{"node":{"fields":{"slug":"/Language-Features/07-Object","title":"객체"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/02-Shared-Data-Types","title":"데이터 타입 공유"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/03-External-Bind-to-Any-JS-Library","title":"External (자바스크립트 라이브러리 바인딩)"}}},{"node":{"fields":{"slug":"/Language-Features/24-Unboxed","title":"언박싱"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/07-Bind-to-Global-JS-Values","title":"Bind to Global JS Values"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/01-Embed-Raw-JavaScript","title":"Embed Raw JavaScript"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/08-JSON","title":"JSON"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/05-Bind-to-JS-Function","title":"Bind to JS Function"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/06-Import-from-Export-to-JS","title":"Import from / Export to JS"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/09-Inlining-Constants","title":"Inlining Constants"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/10-Use-Illegal-Identifier-Names","title":"Use Illegal Identifier Names"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/12-Browser-Support-Polyfills","title":"Browser Support & Polyfills"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/11-Generate-Converters-Helpers","title":"인터롭 코드 자동 생성하기"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/13-Interop-Cheatsheet","title":"Interop Cheatsheet"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/11-Generate-Converters-Helpers/01-@deriving(accessors)","title":"@deriving(accessor)"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/11-Generate-Converters-Helpers/02-@deriving(jsConverter)","title":"@deriving(jsConverter)"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/11-Generate-Converters-Helpers/03-@deriving(abstract)","title":"@deriving(abstract)"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/11-Generate-Converters-Helpers/04-@obj","title":"@obj"}}},{"node":{"fields":{"slug":"/Guides/01-Converting-from-JS","title":"자바스크립트 파일을 변환하기"}}},{"node":{"fields":{"slug":"/Guides/02-Libraries","title":"Libraries"}}},{"node":{"fields":{"slug":"/Extra/01-Newcomer-Examples","title":"초보자를 위한 예제"}}},{"node":{"fields":{"slug":"/Extra/02-Project-Structure","title":"Project Structure"}}},{"node":{"fields":{"slug":"/Extra/03-FAQ","title":"자주 묻는 질문"}}},{"node":{"fields":{"slug":"/Build-System/03-Configuration-Schema","title":"Configuration Schema"}}},{"node":{"fields":{"slug":"/Build-System/04-Interop-with-JS-Build-Systems","title":"Interop with JS Build Systems"}}},{"node":{"fields":{"slug":"/Build-System/01-Overview","title":"Build System Overview"}}},{"node":{"fields":{"slug":"/Build-System/05-Performance","title":"Performance"}}},{"node":{"fields":{"slug":"/Build-System/02-Configuration","title":"Configuration"}}},{"node":{"fields":{"slug":"/ReScript-React/02-Main-Concepts/01-Elements-and-JSX","title":"엘레멘트와 JSX"}}}]}},"pageContext":{"id":"875788f8-b9b5-5bd6-975d-88f012e1f214"}},"staticQueryHashes":["2619113677","2619113677","3706406642","3706406642","417421954","417421954"]}