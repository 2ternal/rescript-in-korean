{"componentChunkName":"component---src-templates-docs-js","path":"/ReScript-React/02-Main-Concepts/01-Elements-and-JSX","result":{"data":{"site":{"siteMetadata":{"title":"ReScript in Korean","docsLocation":"https://github.com/green-labs/rescript-in-korean/tree/main/content"}},"mdx":{"fields":{"id":"a98a38cd-9755-554e-821e-5004d09f5a40","title":"엘레멘트와 JSX","slug":"/ReScript-React/02-Main-Concepts/01-Elements-and-JSX"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"엘레멘트와 JSX\",\n  \"metaTitle\": \"01-엘레멘트와 JSX(Elements & JSX)\",\n  \"metaDescription\": \"Basic concepts for React elements and how to use them in JSX\",\n  \"canonical\": \"https://rescript-lang.org/docs/react/latest/elements-and-jsx\",\n  \"sourceUrl\": \"https://rescript-lang.org/docs/react/latest/elements-and-jsx\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Elements are the smallest building blocks of React apps. This page will explain how to handle \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.element\"), \"s in your React app with our dedicated JSX syntax.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"\\uCC38\\uACE0\"), \" This page assumes your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bsconfig.json\"), \" to be set to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\"reason\\\": { \\\"react-jsx\\\": 3 }\"), \", otherwise your JSX will not be transformed to its React specific form.\")), mdx(\"h2\", null, \"Element Basics\"), mdx(\"p\", null, \"Let's start out by creating our first React element.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"let element = <h1> {React.string(\\\"Hello World\\\")} </h1>\\n\")), mdx(\"p\", null, \"The binding \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"element\"), \" and the expression \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"{React.string(\\\"Hello World\\\")}\"), \" are both of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.element\"), \", the fundamental type for representing React elements within a React application. An element describes what you see on the screen whenever you render your application to the DOM.\"), mdx(\"p\", null, \"Let's say you want to create a function that handles another React element, such as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"children\"), \", you can annotate it as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.element\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"let wrapChildren = (children: React.element) => {\\n  <div>\\n    <h1> {React.string(\\\"Overview\\\")} </h1>\\n    children\\n  </div>\\n}\\n\\nwrapChildren(<div> React.string(\\\"Let's use React with ReScript\\\") </div>)\\n\")), mdx(\"p\", null, \"Understanding the definition of a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.element\"), \" is essential since it is heavily used within the React APIs, such as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ReactDOM.render(element, ...)\"), \", etc. Be aware that JSX doesn't do any automatic \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"string\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.element\"), \" conversion for you (ReScript forces explicit type conversion). For example \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<div> Hello World </div>\"), \" will not type-check (which is actually a good thing because it's also a huge source for subtle bugs!), you need to convert your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\"Hello World\\\"\"), \" with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.string\"), \" function first.\"), mdx(\"p\", null, \"Fortunately our React bindings bring all necessary functionality to represent all relevant data types as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.element\"), \"s.\"), mdx(\"h2\", null, \"Using Elements within JSX\"), mdx(\"p\", null, \"You can compose elements into more complex structures by using JSX:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"let greeting = React.string(\\\"Hello \\\")\\nlet name = React.string(\\\"Stranger\\\");\\n\\n\\n// element is also of type React.element\\nlet element = <div className=\\\"myElement\\\"> greeting name </div>\\n\")), mdx(\"p\", null, \"JSX is the main way to express your React application as a tree of elements.\"), mdx(\"p\", null, \"Sometimes, when doing a lot of interop with existing ReactJS codebases, you'll find yourself in a situation where you can't use JSX syntax due to syntactic restrictions. Check out the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"#escape-hatches\"\n  }), \"Escape Hatches\"), \" chapter later on for workarounds.\"), mdx(\"h2\", null, \"Creating Elements\"), mdx(\"h3\", null, \"Creating Elements from string, int, float, array\"), mdx(\"p\", null, \"Apart from using JSX to create our React elements or React components, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React\"), \" module offers various functions to create elements from primitive data types:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"React.string(\\\"Hello\\\") // new element representing \\\"Hello\\\"\\n\\nReact.int(1) // new element representing \\\"1\\\"\\n\\nReact.float(1.0) // new element representing \\\"1.0\\\"\\n\")), mdx(\"p\", null, \"It also offers \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.array\"), \" to represent multiple elements as one single element (useful for rendering a list of data, or passing children):\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"let element = React.array([\\n  React.string(\\\"element 1\\\"),\\n  React.string(\\\"element 2\\\"),\\n  React.string(\\\"element 3\\\")\\n])\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"\\uCC38\\uACE0\"), \" We don't offer a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.list\"), \" function because a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"list\"), \" value would impose runtime overhead. ReScript cares about clean, idiomatic JS output. If you want to transform a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"list\"), \" of elements to a single React element, combine the output of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Belt.List.toArray\"), \" with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.array\"), \" instead.\"), mdx(\"h3\", null, \"Creating Null Elements\"), mdx(\"p\", null, \"ReScript doesn't allow \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"element || null\"), \" constraints due to it's strongly typed nature. Whenever you are expressing conditionals where a value might, or might not be rendered, you will need the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.null\"), \" constant to represent \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Nothingness\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"let name = Some(\\\"Andrea\\\")\\n\\nlet element = switch name {\\n  | Some(name) => <div> {React.string(\\\"Hello \\\" ++ name)} </div>\\n  | None => React.null\\n}\\n\\n<div> element </div>\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"var name = 'Andrea';\\n\\nvar element = name !== undefined ? React.createElement('div', undefined, 'Hello ' + name) : null;\\n\\nReact.createElement('div', undefined, element);\\n\")), mdx(\"h2\", null, \"Escape Hatches\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"\\uCC38\\uACE0\"), \" This chapter features low level APIs that are used by JSX itself, and should only be used whenever you hit certain JSX syntax limitations. More infos on the JSX internals can be found in our \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"./beyond-jsx\"\n  }), \"Beyond JSX\"), \" section.\"), mdx(\"h3\", null, \"Creating Elements from Component Functions\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"\\uCC38\\uACE0\"), \" Details on components and props will be described in the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"./components-and-props\"\n  }), \"next chapter\"), \".\"), mdx(\"p\", null, \"Sometimes it's necessary to pass around component functions to have more control over \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.element\"), \" creation. Use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.createElement\"), \" function to instantiate your elements:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"type props = {\\\"name\\\": string};\\n\\nlet render = (myComp: props => React.element) => {\\n  <div>\\n    {React.createElement(myComp, {\\\"name\\\": \\\"Franz\\\"})}\\n  </div>\\n}\\n\")), mdx(\"p\", null, \"This feature is often used when interacting with existing JS / ReactJS code. In pure ReScript React applications, you would rather pass a function that does the rendering for you (also called a \\\"render prop\\\"):\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"let render = (renderMyComp: (~name: string) => React.element) => {\\n  <div>\\n    {renderMyComp(\\\"Franz\\\")}\\n  </div>\\n}\\n\")), mdx(\"h4\", null, \"Pass Variadic Children\"), mdx(\"p\", null, \"There is also a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.createElementVariadic\"), \" function, which takes an array of children as a third parameter:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"type props = {\\\"title\\\": string, \\\"children\\\": React.element};\\n\\nlet render = (article: props => React.element) => {\\n  let children = [React.string(\\\"Introduction\\\"), React.string(\\\"Body\\\")];\\n\\n  let props = {\\\"title\\\": \\\"Article #1\\\", \\\"children\\\": React.null};\\n\\n  {React.createElementVariadic(article, props, children)}\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"function render(article) {\\n  var children = ['Introduction'];\\n  var props = {\\n    title: 'Article #1',\\n    children: null,\\n  };\\n  return Caml_splice_call.spliceApply(React.createElement, [article, props, children]);\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"\\uCC38\\uACE0\"), \" Here we are passing a prop \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\"children\\\": React.null\"), \" to satisfy the type checker. React will ignore the children prop in favor of the children array.\"), mdx(\"p\", null, \"This function is mostly used by our JSX transformations, so usually you want to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.createElement\"), \" and pass a children prop instead.\"), mdx(\"h3\", null, \"Creating DOM Elements\"), mdx(\"p\", null, \"To create DOM elements (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<div>\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<span>\"), \", etc.), use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ReactDOMRe.createDOMElementVariadic\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"ReactDOMRe.createDOMElementVariadic(\\\"div\\\", ~props=ReactDOM.domProps(~className=\\\"card\\\", ()), []);\\n\")), mdx(\"p\", null, \"The function above requires the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ReactDOM.domProps\"), \" constructor function, so ReScript can make sure that we are only passing valid dom props. You can find an exhaustive list of all available props in the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/reasonml/reason-react/blob/master/src/ReactDOM.re#L61\"\n  }), \"ReactDOM\"), \" module.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Warning:\"), \" The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ReactDOMRe\"), \" module will be removed in the next major \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rescript-react\"), \" release, so use sparsely!\"), mdx(\"h3\", null, \"Cloning Elements\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"\\uCC38\\uACE0\"), \" This is an escape hatch feature and will only be useful for interoping with existing JS code / libraries.\"), mdx(\"p\", null, \"Sometimes it's required to clone an existing element to set, overwrite or add prop values to a new instance, or if you want to set invalid prop names such as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"data-name\"), \". You can use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.cloneElement\"), \" for that:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"let original = <div className=\\\"hello\\\"/>\\n\\n// Will return a new React.element with className set to \\\"world\\\"\\nReact.cloneElement(original, {\\\"className\\\": \\\"world\\\", \\\"data-name\\\": \\\"some name\\\"});\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"var original = React.createElement('div', {\\n  className: 'hello',\\n});\\n\\nReact.cloneElement(original, {\\n  className: 'world',\\n  'data-name': 'some name',\\n});\\n\")), mdx(\"p\", null, \"The feature mentioned above could also replicate \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"props spreading\"), \", a practise commonly used in ReactJS codebases, but we strongly discourage the usage due to its unsafe nature and its incorrectness (e.g. adding undefined extra props to a component doesn't make sense, and causes hard to find bugs).\"), mdx(\"p\", null, \"In ReScript, we rather pass down required props explicitly to leaf components or use a renderProp instead. We introduced \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/rescript-in-korean/docs/manual/latest/jsx#punning\"\n  }), \"JSX punning\"), \" syntax to make the process of passing down props more convenient.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#element-basics","title":"Element Basics"},{"url":"#using-elements-within-jsx","title":"Using Elements within JSX"},{"url":"#creating-elements","title":"Creating Elements","items":[{"url":"#creating-elements-from-string-int-float-array","title":"Creating Elements from string, int, float, array"},{"url":"#creating-null-elements","title":"Creating Null Elements"}]},{"url":"#escape-hatches","title":"Escape Hatches","items":[{"url":"#creating-elements-from-component-functions","title":"Creating Elements from Component Functions","items":[{"url":"#pass-variadic-children","title":"Pass Variadic Children"}]},{"url":"#creating-dom-elements","title":"Creating DOM Elements"},{"url":"#cloning-elements","title":"Cloning Elements"}]}]},"parent":{"__typename":"File","relativePath":"ReScript-React/02-Main-Concepts/01-Elements-and-JSX.mdx"},"frontmatter":{"metaTitle":"01-엘레멘트와 JSX(Elements & JSX)","metaDescription":"Basic concepts for React elements and how to use them in JSX","sourceUrl":"https://rescript-lang.org/docs/react/latest/elements-and-jsx","canonical":"https://rescript-lang.org/docs/react/latest/elements-and-jsx"}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/Build-System","title":"빌드 시스템"}}},{"node":{"fields":{"slug":"/Extra","title":"그 외"}}},{"node":{"fields":{"slug":"/Guides","title":"가이드"}}},{"node":{"fields":{"slug":"/JavaScript-Interop","title":"자바스크립트 인터롭"}}},{"node":{"fields":{"slug":"/Language-Features","title":"언어적인 특징"}}},{"node":{"fields":{"slug":"/Overview","title":"개요"}}},{"node":{"fields":{"slug":"/ReScript-React","title":"ReScript React"}}},{"node":{"fields":{"slug":"/","title":"ReScript in Korean"}}},{"node":{"fields":{"slug":"/Build-System/01-Overview","title":"Build System Overview"}}},{"node":{"fields":{"slug":"/Build-System/02-Configuration","title":"Configuration"}}},{"node":{"fields":{"slug":"/Build-System/03-Configuration-Schema","title":"Configuration Schema"}}},{"node":{"fields":{"slug":"/Build-System/04-Interop-with-JS-Build-Systems","title":"Interop with JS Build Systems"}}},{"node":{"fields":{"slug":"/Build-System/05-Performance","title":"Performance"}}},{"node":{"fields":{"slug":"/Extra/01-Newcomer-Examples","title":"초보자를 위한 예제"}}},{"node":{"fields":{"slug":"/Extra/02-Project-Structure","title":"Project Structure"}}},{"node":{"fields":{"slug":"/Extra/03-FAQ","title":"자주 묻는 질문"}}},{"node":{"fields":{"slug":"/Guides/01-Converting-from-JS","title":"자바스크립트 파일을 변환하기"}}},{"node":{"fields":{"slug":"/Guides/02-Libraries","title":"Libraries"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/01-Embed-Raw-JavaScript","title":"Embed Raw JavaScript"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/02-Shared-Data-Types","title":"데이터 타입 공유"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/04-Bind-to-JS-Object","title":"자바스크립트 객체에 바인딩하기"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/05-Bind-to-JS-Function","title":"Bind to JS Function"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/06-Import-from-Export-to-JS","title":"Import from / Export to JS"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/07-Bind-to-Global-JS-Values","title":"Bind to Global JS Values"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/08-JSON","title":"JSON"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/09-Inlining-Constants","title":"Inlining Constants"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/10-Use-Illegal-Identifier-Names","title":"Use Illegal Identifier Names"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/11-Generate-Converters-Helpers","title":"인터롭 코드 자동 생성하기"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/12-Browser-Support-Polyfills","title":"Browser Support & Polyfills"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/13-Interop-Cheatsheet","title":"Interop Cheatsheet"}}},{"node":{"fields":{"slug":"/Language-Features/01-Overview","title":"개요"}}},{"node":{"fields":{"slug":"/Language-Features/02-Let-Binding","title":"Let Binding"}}},{"node":{"fields":{"slug":"/Language-Features/03-Type","title":"타입"}}},{"node":{"fields":{"slug":"/Language-Features/04-Primitive-Types","title":"원시 타입"}}},{"node":{"fields":{"slug":"/Language-Features/05-Tuple","title":"튜플"}}},{"node":{"fields":{"slug":"/Language-Features/06-Record","title":"레코드"}}},{"node":{"fields":{"slug":"/Language-Features/07-Object","title":"객체"}}},{"node":{"fields":{"slug":"/Language-Features/08-Variant","title":"배리언트"}}},{"node":{"fields":{"slug":"/Language-Features/09-Polymorphic-Variant","title":"Polymorphic Variant"}}},{"node":{"fields":{"slug":"/Language-Features/10-Null-Undefined-and-Option","title":"Null, Undefined 그리고 Option"}}},{"node":{"fields":{"slug":"/Language-Features/11-Array-List","title":"배열과 리스트"}}},{"node":{"fields":{"slug":"/Language-Features/12-Function","title":"함수"}}},{"node":{"fields":{"slug":"/Language-Features/13-Control-Flow","title":"제어 흐름"}}},{"node":{"fields":{"slug":"/Language-Features/14-Pipe","title":"파이프"}}},{"node":{"fields":{"slug":"/Language-Features/15-Pattern-Matching-Destructuring","title":"패턴 매칭 / 구조분해"}}},{"node":{"fields":{"slug":"/Language-Features/16-Mutation","title":"가변"}}},{"node":{"fields":{"slug":"/Language-Features/17-JSX","title":"JSX"}}},{"node":{"fields":{"slug":"/Language-Features/18-Exception","title":"예외"}}},{"node":{"fields":{"slug":"/Language-Features/19-Lazy-Value","title":"Lazy Value"}}},{"node":{"fields":{"slug":"/Language-Features/20-Async-Promise","title":"Async & Promise"}}},{"node":{"fields":{"slug":"/Language-Features/21-Module","title":"모듈"}}},{"node":{"fields":{"slug":"/Language-Features/22-Import-Export","title":"Import & Export"}}},{"node":{"fields":{"slug":"/Language-Features/23-Attribute-Decorator","title":"속성 (데코레이터)"}}},{"node":{"fields":{"slug":"/Language-Features/24-Unboxed","title":"언박싱"}}},{"node":{"fields":{"slug":"/Language-Features/25-Reserved-Keyword","title":"예약된 키워드"}}},{"node":{"fields":{"slug":"/Overview/01-Introduction","title":"소개"}}},{"node":{"fields":{"slug":"/Overview/02-Installation","title":"설치"}}},{"node":{"fields":{"slug":"/Overview/03-EditorPlugins","title":"편집기 플러그인"}}},{"node":{"fields":{"slug":"/Overview/04-Migrate-to-ReScript-Syntax","title":"리스크립트 문법으로 변경하기"}}},{"node":{"fields":{"slug":"/Overview/05-Try","title":"CLI로 직접 해보기"}}},{"node":{"fields":{"slug":"/ReScript-React/01-Overview","title":"개요"}}},{"node":{"fields":{"slug":"/ReScript-React/02-Main-Concepts","title":"메인 컨셉"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management","title":"리액트 훅과 상태 관리"}}},{"node":{"fields":{"slug":"/ReScript-React/04-Guides","title":"가이드"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/03-External-Bind-to-Any-JS-Library","title":"External (자바스크립트 라이브러리 바인딩)"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/11-Generate-Converters-Helpers/01-@deriving(accessors)","title":"@deriving(accessor)"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/11-Generate-Converters-Helpers/02-@deriving(jsConverter)","title":"@deriving(jsConverter)"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/11-Generate-Converters-Helpers/03-@deriving(abstract)","title":"@deriving(abstract)"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/11-Generate-Converters-Helpers/04-@obj","title":"@obj"}}},{"node":{"fields":{"slug":"/ReScript-React/01-Overview/01-Introduction","title":"소개"}}},{"node":{"fields":{"slug":"/ReScript-React/01-Overview/02-Installation","title":"설치"}}},{"node":{"fields":{"slug":"/ReScript-React/02-Main-Concepts/01-Elements-and-JSX","title":"엘레멘트와 JSX"}}},{"node":{"fields":{"slug":"/ReScript-React/02-Main-Concepts/02-Rendering-Elements","title":"엘레멘트 렌더링하기"}}},{"node":{"fields":{"slug":"/ReScript-React/02-Main-Concepts/03-Components-and-Props","title":"컴포넌트와 Props"}}},{"node":{"fields":{"slug":"/ReScript-React/02-Main-Concepts/04-Arrays-and-Keys","title":"배열과 키"}}},{"node":{"fields":{"slug":"/ReScript-React/02-Main-Concepts/05-Refs-and-the-DOM","title":"Refs와 DOM"}}},{"node":{"fields":{"slug":"/ReScript-React/02-Main-Concepts/06-Context","title":"컨텍스트"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management/01-Hooks-and-State-Management-Overview","title":"리액트 훅과 상태 관리 개요"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management/02-useEffect","title":"useEffect"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management/03-useState","title":"useState"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management/04-useReducer","title":"useReducer"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management/05-useContext","title":"useContext"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management/06-useRef","title":"useRef"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management/07-Build-A-Custom-Hook","title":"커스텀 훅 만들기"}}},{"node":{"fields":{"slug":"/ReScript-React/04-Guides/01-Beyond-JSX","title":"JSX를 넘어서"}}},{"node":{"fields":{"slug":"/ReScript-React/04-Guides/02-Forwarding-Refs","title":"Ref 포워딩하기"}}}]}},"pageContext":{"id":"a98a38cd-9755-554e-821e-5004d09f5a40"}},"staticQueryHashes":["2619113677","2619113677","3706406642","3706406642","417421954","417421954"]}