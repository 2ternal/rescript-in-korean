{"componentChunkName":"component---src-templates-docs-js","path":"/ReScript-React/02-Main-Concepts/05-Refs-and-the-DOM","result":{"data":{"site":{"siteMetadata":{"title":"ReScript in Korean","docsLocation":"https://github.com/green-labs/rescript-in-korean/tree/main/content"}},"mdx":{"fields":{"id":"c2bfe558-1032-5703-9ec8-3bb9023f9d0a","title":"Refs와 DOM","slug":"/ReScript-React/02-Main-Concepts/05-Refs-and-the-DOM"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Refs와 DOM\",\n  \"metaTitle\": \"05-Refs와 DOM(Refs and the DOM)\",\n  \"metaDescription\": \"Using Refs and DOM elements in ReScript and React\",\n  \"canonical\": \"https://rescript-lang.org/docs/react/latest/refs-and-the-dom\",\n  \"sourceUrl\": \"https://rescript-lang.org/docs/react/latest/refs-and-the-dom\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Refs provide a way to access DOM nodes or React elements created within your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"make\"), \" component function.\"), mdx(\"p\", null, \"In the typical React dataflow, \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"./components-and-props\"\n  }), \"props\"), \" are the only way that parent components interact with their children. To modify a child, you re-render it with new props. However, there are a few cases where you need to imperatively modify a child outside of the typical dataflow. The child to be modified could be an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.element\"), \", or it could be a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Dom.element\"), \". For both of these cases, React provides an escape hatch.\"), mdx(\"p\", null, \"A \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.ref\"), \" is defined like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"type t<'value> = { mutable current: 'value }\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Note that the \", mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"Ref.ref\"), \" should not to be confused with the builtin \", mdx(\"a\", _extends({\n    parentName: \"em\"\n  }, {\n    \"href\": \"/rescript-in-korean/docs/manual/latest/mutation\"\n  }), \"ref type\"), \", the language feature that enables mutation.\"))), mdx(\"h2\", null, \"When to use Refs\"), mdx(\"p\", null, \"There are a few good use cases for refs:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Managing state that \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"should not trigger\"), \" any re-render.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Managing focus, text selection, or media playback.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Triggering imperative animations.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Integrating with third-party DOM libraries.\")), mdx(\"p\", null, \"Avoid using refs for anything that can be done declaratively.\"), mdx(\"h2\", null, \"Creating Refs\"), mdx(\"p\", null, \"A React ref is represented as a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.ref('value)\"), \" type, a container managing a mutable value of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'value\"), \". You can create this kind of ref with the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"./hooks-ref\"\n  }), \"React.useRef\"), \" hook:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"@react.component\\nlet make = () => {\\n  let clicks = React.useRef(0);\\n\\n  let onClick = (_) => {\\n    clicks.current = clicks.current + 1;\\n  };\\n\\n  <div onClick>\\n    {Belt.Int.toString(clicks.current)->React.string}\\n  </div>\\n}\\n\")), mdx(\"p\", null, \"The example above defines a binding \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"clicks\"), \" of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.ref(int)\"), \". Note how changing the value \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"clicks.current\"), \" doesn't trigger any re-rendering of the component.\"), mdx(\"h2\", null, \"Accessing Refs\"), mdx(\"p\", null, \"When a ref is passed to an element during render, a reference to the node becomes accessible at the current attribute of the ref.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"let value = myRef.current\\n\")), mdx(\"p\", null, \"The value of the ref differs depending on the type of the node:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"When the ref attribute is used on an HTML element, the ref passed via \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ReactDOM.Ref.domRef\"), \" receives the underlying DOM element as its current property (type of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"React.ref<Js.Nullable.t<Dom.element>>\"), \")\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"In case of interop, when the ref attribute is used on a custom class component (based on JS classes), the ref object receives the mounted instance of the component as its current (not discussed in this document).\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"You may not use the ref attribute on component functions\"), \" because they don\\u2019t have instances (we don't expose JS classes in ReScript).\")), mdx(\"p\", null, \"Here are some examples:\"), mdx(\"h3\", null, \"Adding a Ref to a DOM Element\"), mdx(\"p\", null, \"This code uses a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.ref\"), \" to store a reference to an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"input\"), \" DOM node to put focus on a text field when a button was clicked:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"// CustomTextInput.res\\n\\n@bs.send external focus: Dom.element => unit = \\\"focus\\\"\\n\\n@react.component\\nlet make = () => {\\n  let textInput = React.useRef(Js.Nullable.null)\\n\\n  let focusInput = () =>\\n    switch textInput.current->Js.Nullable.toOption {\\n    | Some(dom) => dom->focus\\n    | None => ()\\n    }\\n\\n  let onClick = _ => focusInput()\\n\\n  <div>\\n    <input type_=\\\"text\\\" ref={ReactDOM.Ref.domRef(textInput)} />\\n    <input type_=\\\"button\\\" value=\\\"Focus the text input\\\" onClick />\\n  </div>\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"function CustomTextInput(Props) {\\n  var textInput = React.useRef(null);\\n  var onClick = function(param) {\\n    var dom = textInput.current;\\n    if (!(dom == null)) {\\n      dom.focus();\\n      return;\\n    }\\n  };\\n  return React.createElement(\\n    'div',\\n    undefined,\\n    React.createElement('input', {\\n      ref: textInput,\\n      type: 'text',\\n    }),\\n    React.createElement('input', {\\n      type: 'button',\\n      value: 'Focus the text input',\\n      onClick: onClick,\\n    })\\n  );\\n}\\n\")), mdx(\"p\", null, \"A few things happened here, so let's break them down:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We initialize our \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"textInput\"), \" ref as a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Js.Nullable.null\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We register our \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"textInput\"), \" ref in our \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"<input>\"), \" element with \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ReactDOM.Ref.domRef(textInput)\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"In our \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"focusInput\"), \" function, we need to first verify that our DOM element is set, and then use the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"focus\"), \" binding to set the focus\")), mdx(\"p\", null, \"React will assign the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"current\"), \" field with the DOM element when the component mounts, and assign it back to null when it unmounts.\"), mdx(\"h3\", null, \"Refs and Component Functions\"), mdx(\"p\", null, \"In React, you \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"can't\"), \" pass a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ref\"), \" attribute to a component function:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"module MyComp = {\\n  @react.component\\n  let make = (~ref) => <input />\\n}\\n\\n@react.component\\nlet make = () => {\\n  let textInput = React.useRef(Js.Nullable.null)\\n\\n  // This will **not** work\\n  <MyComp ref={ReactDOM.Ref.domRef(textInput)} />\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Compiler Error:\\n// Ref cannot be passed as a normal prop. Please use `forwardRef`\\n// API instead\\n\")), mdx(\"p\", null, \"The snippet above will not compile and output an error that looks like this: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\"Ref cannot be passed as a normal prop. Please use forwardRef API instead.\\\"\"), \".\"), mdx(\"p\", null, \"As the error message implies, If you want to allow people to take a ref to your component function, you can use \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"./forwarding-refs\"\n  }), \"ref forwarding\"), \" (possibly in conjunction with useImperativeHandle) instead.\"), mdx(\"h2\", null, \"Exposing DOM Refs to Parent Components\"), mdx(\"p\", null, \"In rare cases, you might want to have access to a child\\u2019s DOM node from a parent component. This is generally not recommended because it breaks component encapsulation, but it can occasionally be useful for triggering focus or measuring the size or position of a child DOM node.\"), mdx(\"p\", null, \"we recommend to use \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"./forwarding-refs\"\n  }), \"ref forwarding\"), \" for these cases. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Ref forwarding lets components opt into exposing any child component\\u2019s ref as their own\"), \". You can find a detailed example of how to expose a child\\u2019s DOM node to a parent component in the ref forwarding documentation.\"), mdx(\"h2\", null, \"Callback Refs\"), mdx(\"p\", null, \"React also supports another way to set refs called \\u201Ccallback refs\\u201D (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.Ref.callbackDomRef\"), \"), which gives more fine-grain control over when refs are set and unset.\"), mdx(\"p\", null, \"Instead of passing a ref value created by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.useRef()\"), \", you can pass in a callback function. The function receives the target \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Dom.element\"), \" as its argument, which can be stored and accessed elsewhere.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"\\uCC38\\uACE0\"), \" Usually we'd use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.Ref.domRef()\"), \" to pass a ref value, but for callback refs, we use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.Ref.callbackDomRef()\"), \" instead.\"), mdx(\"p\", null, \"The example below implements a common pattern: using the ref callback to store a reference to a DOM node in an instance property.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"// CustomTextInput.re\\n\\n@bs.send external focus: Dom.element => unit = \\\"focus\\\"\\n\\n@react.component\\nlet make = () => {\\n  let textInput = React.useRef(Js.Nullable.null)\\n  let setTextInputRef = element => {\\n    textInput.current = element;\\n  }\\n\\n  let focusTextInput = _ => {\\n    textInput.current\\n    ->Js.Nullable.toOption\\n    ->Belt.Option.forEach(input => input->focus)\\n  }\\n\\n  <div>\\n    <input type_=\\\"text\\\" ref={ReactDOM.Ref.callbackDomRef(setTextInputRef)} />\\n    <input\\n      type_=\\\"button\\\" value=\\\"Focus the text input\\\" onClick={focusTextInput}\\n    />\\n  </div>\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"function CustomTextInput(Props) {\\n  var textInput = React.useRef(null);\\n  var setTextInputRef = function(element) {\\n    textInput.current = element;\\n  };\\n  var focusTextInput = function(param) {\\n    return Belt_Option.forEach(Caml_option.nullable_to_opt(textInput.current), function(input) {\\n      input.focus();\\n    });\\n  };\\n  return React.createElement(\\n    'div',\\n    undefined,\\n    React.createElement('input', {\\n      ref: setTextInputRef,\\n      type: 'text',\\n    }),\\n    React.createElement('input', {\\n      type: 'button',\\n      value: 'Focus the text input',\\n      onClick: focusTextInput,\\n    })\\n  );\\n}\\n\")), mdx(\"p\", null, \"React will call the ref callback with the DOM element when the component mounts, and call it with null when it unmounts.\"), mdx(\"p\", null, \"You can pass callback refs between components like you can with object refs that were created with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.useRef()\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"// Parent.res\\n\\n@bs.send external focus: Dom.element => unit = \\\"focus\\\"\\n\\nmodule CustomTextInput = {\\n  @react.component\\n  let make = (~setInputRef) => {\\n    <div>\\n      <input type_=\\\"text\\\" ref={ReactDOM.Ref.callbackDomRef(setInputRef)} />\\n    </div>\\n  }\\n}\\n\\n@react.component\\nlet make = () => {\\n  let textInput = React.useRef(Js.Nullable.null)\\n  let setInputRef = element => { textInput.current = element}\\n\\n  <CustomTextInput setInputRef/>\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"function CustomTextInput(Props) {\\n  var setInputRef = Props.setInputRef;\\n  return React.createElement(\\n    'div',\\n    undefined,\\n    React.createElement('input', {\\n      ref: setInputRef,\\n      type: 'text',\\n    })\\n  );\\n}\\n\\nvar CustomTextInput = {\\n  make: CustomTextInput,\\n};\\n\\nfunction Parent(Props) {\\n  var textInput = React.useRef(null);\\n  var setInputRef = function(element) {\\n    textInput.current = element;\\n  };\\n  return React.createElement(CustomTextInput, {\\n    setInputRef: setInputRef,\\n  });\\n}\\n\")), mdx(\"p\", null, \"In the example above, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Parent\"), \" passes its ref callback as an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setInputRef\"), \" prop to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CustomTextInput\"), \", and the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CustomTextInput\"), \" passes the same function as a special ref attribute to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<input>\"), \". As a result, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"textInput\"), \" ref in Parent will be set to the DOM node corresponding to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<input>\"), \" element in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CustomTextInput\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#when-to-use-refs","title":"When to use Refs"},{"url":"#creating-refs","title":"Creating Refs"},{"url":"#accessing-refs","title":"Accessing Refs","items":[{"url":"#adding-a-ref-to-a-dom-element","title":"Adding a Ref to a DOM Element"},{"url":"#refs-and-component-functions","title":"Refs and Component Functions"}]},{"url":"#exposing-dom-refs-to-parent-components","title":"Exposing DOM Refs to Parent Components"},{"url":"#callback-refs","title":"Callback Refs"}]},"parent":{"__typename":"File","relativePath":"ReScript-React/02-Main-Concepts/05-Refs-and-the-DOM.mdx"},"frontmatter":{"metaTitle":"05-Refs와 DOM(Refs and the DOM)","metaDescription":"Using Refs and DOM elements in ReScript and React","sourceUrl":"https://rescript-lang.org/docs/react/latest/refs-and-the-dom","canonical":"https://rescript-lang.org/docs/react/latest/refs-and-the-dom"}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/Build-System","title":"빌드 시스템"}}},{"node":{"fields":{"slug":"/Extra","title":"그 외"}}},{"node":{"fields":{"slug":"/Guides","title":"가이드"}}},{"node":{"fields":{"slug":"/JavaScript-Interop","title":"자바스크립트 인터롭"}}},{"node":{"fields":{"slug":"/Language-Features","title":"언어적인 특징"}}},{"node":{"fields":{"slug":"/Overview","title":"개요"}}},{"node":{"fields":{"slug":"/ReScript-React","title":"ReScript React"}}},{"node":{"fields":{"slug":"/","title":"ReScript in Korean"}}},{"node":{"fields":{"slug":"/Build-System/01-Overview","title":"Build System Overview"}}},{"node":{"fields":{"slug":"/Build-System/02-Configuration","title":"Configuration"}}},{"node":{"fields":{"slug":"/Build-System/03-Configuration-Schema","title":"Configuration Schema"}}},{"node":{"fields":{"slug":"/Build-System/04-Interop-with-JS-Build-Systems","title":"Interop with JS Build Systems"}}},{"node":{"fields":{"slug":"/Build-System/05-Performance","title":"Performance"}}},{"node":{"fields":{"slug":"/Extra/01-Newcomer-Examples","title":"초보자를 위한 예제"}}},{"node":{"fields":{"slug":"/Extra/02-Project-Structure","title":"Project Structure"}}},{"node":{"fields":{"slug":"/Extra/03-FAQ","title":"자주 묻는 질문"}}},{"node":{"fields":{"slug":"/Guides/01-Converting-from-JS","title":"자바스크립트 파일을 변환하기"}}},{"node":{"fields":{"slug":"/Guides/02-Libraries","title":"Libraries"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/04-Bind-to-JS-Object","title":"자바스크립트 객체에 바인딩하기"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/05-Bind-to-JS-Function","title":"Bind to JS Function"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/06-Import-from-Export-to-JS","title":"Import from / Export to JS"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/07-Bind-to-Global-JS-Values","title":"Bind to Global JS Values"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/08-JSON","title":"JSON"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/09-Inlining-Constants","title":"Inlining Constants"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/10-Use-Illegal-Identifier-Names","title":"Use Illegal Identifier Names"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/11-Generate-Converters-Helpers","title":"인터롭 코드 자동 생성하기"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/12-Browser-Support-Polyfills","title":"Browser Support & Polyfills"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/13-Interop-Cheatsheet","title":"Interop Cheatsheet"}}},{"node":{"fields":{"slug":"/Language-Features/01-Overview","title":"개요"}}},{"node":{"fields":{"slug":"/Language-Features/02-Let-Binding","title":"Let Binding"}}},{"node":{"fields":{"slug":"/Language-Features/03-Type","title":"타입"}}},{"node":{"fields":{"slug":"/Language-Features/04-Primitive-Types","title":"원시 타입"}}},{"node":{"fields":{"slug":"/Language-Features/05-Tuple","title":"튜플"}}},{"node":{"fields":{"slug":"/Language-Features/06-Record","title":"레코드"}}},{"node":{"fields":{"slug":"/Language-Features/07-Object","title":"객체"}}},{"node":{"fields":{"slug":"/Language-Features/08-Variant","title":"배리언트"}}},{"node":{"fields":{"slug":"/Language-Features/09-Polymorphic-Variant","title":"Polymorphic Variant"}}},{"node":{"fields":{"slug":"/Language-Features/10-Null-Undefined-and-Option","title":"Null, Undefined 그리고 Option"}}},{"node":{"fields":{"slug":"/Language-Features/11-Array-List","title":"배열과 리스트"}}},{"node":{"fields":{"slug":"/Language-Features/12-Function","title":"함수"}}},{"node":{"fields":{"slug":"/Language-Features/13-Control-Flow","title":"제어 흐름"}}},{"node":{"fields":{"slug":"/Language-Features/14-Pipe","title":"파이프"}}},{"node":{"fields":{"slug":"/Language-Features/15-Pattern-Matching-Destructuring","title":"패턴 매칭 / 구조분해"}}},{"node":{"fields":{"slug":"/Language-Features/16-Mutation","title":"가변"}}},{"node":{"fields":{"slug":"/Language-Features/17-JSX","title":"JSX"}}},{"node":{"fields":{"slug":"/Language-Features/18-Exception","title":"예외"}}},{"node":{"fields":{"slug":"/Language-Features/19-Lazy-Value","title":"Lazy Value"}}},{"node":{"fields":{"slug":"/Language-Features/20-Async-Promise","title":"Async & Promise"}}},{"node":{"fields":{"slug":"/Language-Features/21-Module","title":"모듈"}}},{"node":{"fields":{"slug":"/Language-Features/22-Import-Export","title":"Import & Export"}}},{"node":{"fields":{"slug":"/Language-Features/23-Attribute-Decorator","title":"속성 (데코레이터)"}}},{"node":{"fields":{"slug":"/Language-Features/24-Unboxed","title":"언박싱"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/03-External-Bind-to-Any-JS-Library","title":"External (자바스크립트 라이브러리 바인딩)"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/02-Shared-Data-Types","title":"데이터 타입 공유"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/01-Embed-Raw-JavaScript","title":"Embed Raw JavaScript"}}},{"node":{"fields":{"slug":"/Language-Features/25-Reserved-Keyword","title":"예약된 키워드"}}},{"node":{"fields":{"slug":"/Overview/01-Introduction","title":"소개"}}},{"node":{"fields":{"slug":"/Overview/02-Installation","title":"설치"}}},{"node":{"fields":{"slug":"/Overview/03-EditorPlugins","title":"편집기 플러그인"}}},{"node":{"fields":{"slug":"/Overview/04-Migrate-to-ReScript-Syntax","title":"리스크립트 문법으로 변경하기"}}},{"node":{"fields":{"slug":"/Overview/05-Try","title":"CLI로 직접 해보기"}}},{"node":{"fields":{"slug":"/ReScript-React/01-Overview","title":"개요"}}},{"node":{"fields":{"slug":"/ReScript-React/02-Main-Concepts","title":"메인 컨셉"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management","title":"리액트 훅과 상태 관리"}}},{"node":{"fields":{"slug":"/ReScript-React/04-Guides","title":"가이드"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/11-Generate-Converters-Helpers/01-@deriving(accessors)","title":"@deriving(accessor)"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/11-Generate-Converters-Helpers/02-@deriving(jsConverter)","title":"@deriving(jsConverter)"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/11-Generate-Converters-Helpers/03-@deriving(abstract)","title":"@deriving(abstract)"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/11-Generate-Converters-Helpers/04-@obj","title":"@obj"}}},{"node":{"fields":{"slug":"/ReScript-React/01-Overview/01-Introduction","title":"소개"}}},{"node":{"fields":{"slug":"/ReScript-React/01-Overview/02-Installation","title":"설치"}}},{"node":{"fields":{"slug":"/ReScript-React/02-Main-Concepts/01-Elements-and-JSX","title":"엘레멘트와 JSX"}}},{"node":{"fields":{"slug":"/ReScript-React/02-Main-Concepts/02-Rendering-Elements","title":"엘레멘트 렌더링하기"}}},{"node":{"fields":{"slug":"/ReScript-React/02-Main-Concepts/03-Components-and-Props","title":"컴포넌트와 Props"}}},{"node":{"fields":{"slug":"/ReScript-React/02-Main-Concepts/04-Arrays-and-Keys","title":"배열과 키"}}},{"node":{"fields":{"slug":"/ReScript-React/02-Main-Concepts/05-Refs-and-the-DOM","title":"Refs와 DOM"}}},{"node":{"fields":{"slug":"/ReScript-React/02-Main-Concepts/06-Context","title":"컨텍스트"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management/01-Hooks-and-State-Management-Overview","title":"리액트 훅과 상태 관리 개요"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management/02-useEffect","title":"useEffect"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management/03-useState","title":"useState"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management/04-useReducer","title":"useReducer"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management/05-useContext","title":"useContext"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management/06-useRef","title":"useRef"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management/07-Build-A-Custom-Hook","title":"커스텀 훅 만들기"}}},{"node":{"fields":{"slug":"/ReScript-React/04-Guides/01-Beyond-JSX","title":"JSX를 넘어서"}}},{"node":{"fields":{"slug":"/ReScript-React/04-Guides/02-Forwarding-Refs","title":"Ref 포워딩하기"}}}]}},"pageContext":{"id":"c2bfe558-1032-5703-9ec8-3bb9023f9d0a"}},"staticQueryHashes":["2619113677","2619113677","3706406642","3706406642","417421954","417421954"]}