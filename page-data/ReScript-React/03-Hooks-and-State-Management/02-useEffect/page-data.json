{"componentChunkName":"component---src-templates-docs-js","path":"/ReScript-React/03-Hooks-and-State-Management/02-useEffect","result":{"data":{"site":{"siteMetadata":{"title":"ReScript in Korean","docsLocation":"https://github.com/green-labs/rescript-in-korean/tree/main/content"}},"mdx":{"fields":{"id":"21f2ce49-a242-5cd2-9de0-d19aa353564d","title":"useEffect","slug":"/ReScript-React/03-Hooks-and-State-Management/02-useEffect"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"useEffect\",\n  \"metaTitle\": \"02-useEffect Hook\",\n  \"metaDescription\": \"Details about the useEffect React hook in ReScript\",\n  \"canonical\": \"https://rescript-lang.org/docs/react/latest/hooks-effect\",\n  \"sourceUrl\": \"https://rescript-lang.org/docs/react/latest/hooks-effect\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Effect\"), \" Hook lets you perform side effects in function components.\"), mdx(\"h2\", null, \"What are Effects?\"), mdx(\"p\", null, \"Common examples for (side) effects are data fetching, setting up a subscription, and manually changing the DOM in React components.\"), mdx(\"p\", null, \"There are two common kinds of side effects in React components: those that don\\u2019t require cleanup, and those that do. We'll look into the distinction later on in our examples, but first let's see how the interface looks like.\"), mdx(\"h2\", null, \"\\uAE30\\uBCF8 \\uC0AC\\uC6A9\\uBC95\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-reason\"\n  }, \"// Runs after every completed render\\nReact.useEffect(() => {\\n  // Run effects\\n  None // or Some(() => {})\\n})\\n\\n\\n// Runs only once right after mounting the component\\nReact.useEffect0(() => {\\n  // Run effects\\n  None // or Some(() => {})\\n})\\n\\n// Runs everytime `prop1` has changed\\nReact.useEffect1(() => {\\n  // Run effects based on prop1\\n  None\\n}, [prop1])\\n\\n// Runs everytime `prop1` or `prop2` has changed\\nReact.useEffect2(() => {\\n  // Run effects based on prop1 / prop2\\n  None\\n}, (prop1, prop2))\\n\\nReact.useEffect3(() => {\\n  None\\n}, (prop1, prop2, prop3));\\n\\n// useEffect4...7 with according dependency\\n// tuple just like useEffect3\\n\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"React.useEffect(function() {});\\nReact.useEffect(function() {}, []);\\nReact.useEffect(function() {}, [prop1]);\\nReact.useEffect(function() {}, [prop1, prop2]);\\nReact.useEffect(function() {}, [prop1, prop2, prop3]);\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.useEffect\"), \" receives a function that contains imperative, possibly effectful code, and returns a value \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"option<unit => unit>\"), \" as a potential cleanup function.\"), mdx(\"p\", null, \"A \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \" call may receive an additional array of dependencies (see \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.useEffect1\"), \" / \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.useEffect2...7\"), \"). The effect function will run whenever one of the provided dependencies has changed. More details on why this is useful \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#effect-dependencies\"\n  }, \"down below\"), \".\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"\\uCC38\\uACE0\"), \" You probably wonder why \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.useEffect1\"), \" receives an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"array\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useEffect2\"), \" etc require a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tuple\"), \" (e.g. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(prop1, prop2)\"), \") for the dependency list. That's because a tuple can receive multiple values of different types, whereas an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"array\"), \" only accepts values of identical types. It's possible to replicate \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useEffect2\"), \" by doing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.useEffect1(fn, [1, 2])\"), \", on other hand the type checker wouldn't allow \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.useEffect1(fn, [1, \\\"two\\\"])\"), \".\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.useEffect\"), \" will run its function after every completed render, while \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.useEffect0\"), \" will only run the effect on the first render (when the component has mounted).\"), mdx(\"h2\", null, \"Examples\"), mdx(\"h3\", null, \"Effects without Cleanup\"), mdx(\"p\", null, \"Sometimes, we want to run some additional code after React has updated the DOM. Network requests, manual DOM mutations, and logging are common examples of effects that don\\u2019t require a cleanup. We say that because we can run them and immediately forget about them.\"), mdx(\"p\", null, \"As an example, let's write a counter component that updates \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"document.title\"), \" on every render:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-reason\"\n  }, \"// Counter.re\\nmodule Document = {\\n  type t;\\n  @bs.val external document: t = \\\"document\\\";\\n  @bs.set external setTitle: (t, string) => unit = \\\"title\\\"\\n}\\n\\n@react.component\\nlet make = () => {\\n  let (count, setCount) = React.useState(_ => 0);\\n\\n  React.useEffect(() => {\\n    open Document\\n    document->setTitle(`You clicked ${Belt.Int.toString(count)} times!`)\\n    None\\n  }, );\\n\\n  let onClick = (_evt) => {\\n    setCount(prev => prev + 1)\\n  };\\n\\n  let msg = \\\"You clicked\\\" ++ Belt.Int.toString(count) ++  \\\"times\\\"\\n\\n  <div>\\n    <p>{React.string(msg)}</p>\\n    <button onClick> {React.string(\\\"Click me\\\")} </button>\\n  </div>\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function Counter(Props) {\\n  var match = React.useState(function() {\\n    return 0;\\n  });\\n  var setCount = match[1];\\n  var count = match[0];\\n  React.useEffect(function() {\\n    document.title = 'You clicked ' + String(count) + ' times!';\\n  });\\n  var onClick = function(_evt) {\\n    return Curry._1(setCount, function(prev) {\\n      return (prev + 1) | 0;\\n    });\\n  };\\n  var msg = 'You clicked' + String(count) + 'times';\\n  return React.createElement(\\n    'div',\\n    undefined,\\n    React.createElement('p', undefined, msg),\\n    React.createElement(\\n      'button',\\n      {\\n        onClick: onClick,\\n      },\\n      'Click me'\\n    )\\n  );\\n}\\n\")), mdx(\"p\", null, \"In case we want to make the effects dependent on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"count\"), \", we can just use following \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \" call instead:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-reason\"\n  }, \" React.useEffect1(() => {\\n    open Document\\n    document->setTitle(`You clicked ${Belt.Int.toString(count)} times!`)\\n    None\\n  }, [count]);\\n\")), mdx(\"p\", null, \"Now instead of running an effect on every render, it will only run when \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"count\"), \" has a different value than in the render before.\"), mdx(\"h3\", null, \"Effects with Cleanup\"), mdx(\"p\", null, \"Earlier, we looked at how to express side effects that don\\u2019t require any cleanup. However, some effects do. For example, we might want to set up a subscription to some external data source. In that case, it is important to clean up so that we don\\u2019t introduce a memory leak!\"), mdx(\"p\", null, \"Let's look at an example that gracefully subscribes, and later on unsubscribes from some subscription API:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-reason\"\n  }, \"// FriendStatus.res\\n\\nmodule ChatAPI = {\\n  // Imaginary globally available ChatAPI for demo purposes\\n  type status = { isOnline: bool };\\n  @bs.val external subscribeToFriendStatus: (string, status => unit) => unit = \\\"subscribeToFriendStatus\\\";\\n  @bs.val external unsubscribeFromFriendStatus: (string, status => unit) => unit = \\\"unsubscribeFromFriendStatus\\\";\\n}\\n\\ntype state = Offline | Loading | Online;\\n\\n@react.component\\nlet make = (~friendId: string) => {\\n  let (state, setState) = React.useState(_ => Offline)\\n\\n  React.useEffect(() => {\\n    let handleStatusChange = (status) => {\\n      setState(_ => {\\n        status.ChatAPI.isOnline ? Online : Offline\\n      })\\n    }\\n\\n    ChatAPI.subscribeToFriendStatus(friendId, handleStatusChange);\\n    setState(_ => Loading);\\n\\n    let cleanup = () => {\\n      ChatAPI.unsubscribeFromFriendStatus(friendId, handleStatusChange)\\n    }\\n\\n    Some(cleanup)\\n  })\\n\\n  let text = switch(state) {\\n    | Offline => friendId ++ \\\" is offline\\\"\\n    | Online => friendId ++ \\\" is online\\\"\\n    | Loading => \\\"loading...\\\"\\n  }\\n\\n  <div>\\n    {React.string(text)}\\n  </div>\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function FriendStatus(Props) {\\n  var friendId = Props.friendId;\\n  var match = React.useState(function() {\\n    return /* Offline */ 0;\\n  });\\n  var setState = match[1];\\n  React.useEffect(function() {\\n    var handleStatusChange = function(status) {\\n      return Curry._1(setState, function(param) {\\n        if (status.isOnline) {\\n          return /* Online */ 2;\\n        } else {\\n          return /* Offline */ 0;\\n        }\\n      });\\n    };\\n    subscribeToFriendStatus(friendId, handleStatusChange);\\n    Curry._1(setState, function(param) {\\n      return /* Loading */ 1;\\n    });\\n    return function(param) {\\n      unsubscribeFromFriendStatus(friendId, handleStatusChange);\\n    };\\n  });\\n  var text;\\n  switch (match[0]) {\\n    case /* Offline */ 0:\\n      text = friendId + ' is offline';\\n      break;\\n    case /* Loading */ 1:\\n      text = 'loading...';\\n      break;\\n    case /* Online */ 2:\\n      text = friendId + ' is online';\\n      break;\\n  }\\n  return React.createElement('div', undefined, text);\\n}\\n\")), mdx(\"h2\", null, \"Effect Dependencies\"), mdx(\"p\", null, \"In some cases, cleaning up or applying the effect after every render might create a performance problem. Let's look at a concrete example to see what \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \" does:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-reason\"\n  }, \"// from a previous example above\\nReact.useEffect1(() => {\\n  open Document\\n  document->setTitle(`You clicked ${Belt.Int.toString(count)} times!`)\\n  None;\\n}, [count]);\\n\")), mdx(\"p\", null, \"Here, we pass \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[count]\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useEffect1\"), \" as a dependency. What does this mean? If the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"count\"), \" is 5, and then our component re-renders with count still equal to 5, React will compare \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[5]\"), \" from the previous render and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[5]\"), \" from the next render. Because all items within the array are the same (5 === 5), React would skip the effect. That\\u2019s our optimization.\"), mdx(\"p\", null, \"When we render with count updated to 6, React will compare the items in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[5]\"), \" array from the previous render to items in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[6]\"), \" array from the next render. This time, React will re-apply the effect because \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"5 !== 6\"), \". If there are multiple items in the array, React will re-run the effect even if just one of them is different.\"), mdx(\"p\", null, \"This also works for effects that have a cleanup phase:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-reason\"\n  }, \"// from a previous example above\\nReact.useEffect1(() => {\\n  let handleStatusChange = (status) => {\\n    setState(_ => {\\n      status.ChatAPI.isOnline ? Online : Offline\\n    })\\n  }\\n\\n  ChatAPI.subscribeToFriendStatus(friendId, handleStatusChange);\\n  setState(_ => Loading);\\n\\n  let cleanup = () => {\\n    ChatAPI.unsubscribeFromFriendStatus(friendId, handleStatusChange)\\n  }\\n\\n  Some(cleanup)\\n}, [friendId]) // Only re-subscribe if friendId changes\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"\\uC911\\uC694\"), \" If you use this optimization, make sure the array includes all values from the component scope (such as props and state) that change over time and that are used by the effect. Otherwise, your code will reference stale values from previous renders\"), mdx(\"p\", null, \"If you want to run an effect and clean it up only once (on mount and unmount), use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.useEffect0\"), \".\"), mdx(\"p\", null, \"If you are interested in more performance optmization related topics, have a look at the ReactJS \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://reactjs.org/docs/hooks-faq.html#performance-optimizations\"\n  }, \"Performance Optimization Docs\"), \" for more detailed infos.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#what-are-effects","title":"What are Effects?"},{"url":"#기본-사용법","title":"기본 사용법"},{"url":"#examples","title":"Examples","items":[{"url":"#effects-without-cleanup","title":"Effects without Cleanup"},{"url":"#effects-with-cleanup","title":"Effects with Cleanup"}]},{"url":"#effect-dependencies","title":"Effect Dependencies"}]},"parent":{"__typename":"File","relativePath":"ReScript-React/03-Hooks-and-State-Management/02-useEffect.mdx"},"frontmatter":{"metaTitle":"02-useEffect Hook","metaDescription":"Details about the useEffect React hook in ReScript","sourceUrl":"https://rescript-lang.org/docs/react/latest/hooks-effect","canonical":"https://rescript-lang.org/docs/react/latest/hooks-effect"}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/Extra","title":"그 외"}}},{"node":{"fields":{"slug":"/ReScript-React/02-Main-Concepts/02-Rendering-Elements","title":"엘레멘트 렌더링하기"}}},{"node":{"fields":{"slug":"/ReScript-React/02-Main-Concepts/04-Arrays-and-Keys","title":"배열과 키"}}},{"node":{"fields":{"slug":"/Guides","title":"가이드"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/04-Bind-to-JS-Object","title":"자바스크립트 객체에 바인딩하기"}}},{"node":{"fields":{"slug":"/Overview","title":"개요"}}},{"node":{"fields":{"slug":"/Language-Features","title":"언어적인 특징"}}},{"node":{"fields":{"slug":"/ReScript-React/02-Main-Concepts","title":"메인 컨셉"}}},{"node":{"fields":{"slug":"/JavaScript-Interop","title":"자바스크립트 인터롭"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management","title":"리액트 훅과 상태 관리"}}},{"node":{"fields":{"slug":"/ReScript-React/01-Overview","title":"개요"}}},{"node":{"fields":{"slug":"/Build-System","title":"빌드 시스템"}}},{"node":{"fields":{"slug":"/ReScript-React","title":"ReScript React"}}},{"node":{"fields":{"slug":"/","title":"ReScript in Korean"}}},{"node":{"fields":{"slug":"/ReScript-React/04-Guides","title":"가이드"}}},{"node":{"fields":{"slug":"/ReScript-React/04-Guides/02-Forwarding-Refs","title":"Ref 포워딩하기"}}},{"node":{"fields":{"slug":"/ReScript-React/04-Guides/01-Beyond-JSX","title":"JSX를 넘어서"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management/01-Hooks-and-State-Management-Overview","title":"리액트 훅과 상태 관리 개요"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management/02-useEffect","title":"useEffect"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management/03-useState","title":"useState"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management/05-useContext","title":"useContext"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management/04-useReducer","title":"useReducer"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management/06-useRef","title":"useRef"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management/07-Build-A-Custom-Hook","title":"커스텀 훅 만들기"}}},{"node":{"fields":{"slug":"/ReScript-React/02-Main-Concepts/05-Refs-and-the-DOM","title":"Refs와 DOM"}}},{"node":{"fields":{"slug":"/Overview/02-Installation","title":"설치"}}},{"node":{"fields":{"slug":"/Overview/01-Introduction","title":"소개"}}},{"node":{"fields":{"slug":"/ReScript-React/01-Overview/01-Introduction","title":"소개"}}},{"node":{"fields":{"slug":"/ReScript-React/02-Main-Concepts/06-Context","title":"컨텍스트"}}},{"node":{"fields":{"slug":"/ReScript-React/01-Overview/02-Installation","title":"설치"}}},{"node":{"fields":{"slug":"/Overview/03-EditorPlugins","title":"편집기 플러그인"}}},{"node":{"fields":{"slug":"/Language-Features/02-Let-Binding","title":"Let Binding"}}},{"node":{"fields":{"slug":"/Language-Features/01-Overview","title":"개요"}}},{"node":{"fields":{"slug":"/Overview/04-Migrate-to-ReScript-Syntax","title":"리스크립트 문법으로 변경하기"}}},{"node":{"fields":{"slug":"/Language-Features/06-Record","title":"레코드"}}},{"node":{"fields":{"slug":"/Language-Features/03-Type","title":"타입"}}},{"node":{"fields":{"slug":"/Overview/05-Try","title":"CLI로 직접 해보기"}}},{"node":{"fields":{"slug":"/Language-Features/04-Primitive-Types","title":"원시 타입"}}},{"node":{"fields":{"slug":"/Language-Features/10-Null-Undefined-and-Option","title":"Null, Undefined 그리고 Option"}}},{"node":{"fields":{"slug":"/Language-Features/05-Tuple","title":"튜플"}}},{"node":{"fields":{"slug":"/Language-Features/08-Variant","title":"배리언트"}}},{"node":{"fields":{"slug":"/Language-Features/09-Polymorphic-Variant","title":"Polymorphic Variant"}}},{"node":{"fields":{"slug":"/Language-Features/11-Array-List","title":"배열과 리스트"}}},{"node":{"fields":{"slug":"/Language-Features/13-Control-Flow","title":"제어 흐름"}}},{"node":{"fields":{"slug":"/Language-Features/14-Pipe","title":"파이프"}}},{"node":{"fields":{"slug":"/Language-Features/15-Pattern-Matching-Destructuring","title":"패턴 매칭 / 구조분해"}}},{"node":{"fields":{"slug":"/Language-Features/17-JSX","title":"JSX"}}},{"node":{"fields":{"slug":"/Language-Features/16-Mutation","title":"가변"}}},{"node":{"fields":{"slug":"/Language-Features/18-Exception","title":"예외"}}},{"node":{"fields":{"slug":"/Language-Features/12-Function","title":"함수"}}},{"node":{"fields":{"slug":"/Language-Features/20-Async-Promise","title":"Async & Promise"}}},{"node":{"fields":{"slug":"/Language-Features/19-Lazy-Value","title":"Lazy Value"}}},{"node":{"fields":{"slug":"/Language-Features/22-Import-Export","title":"Import & Export"}}},{"node":{"fields":{"slug":"/Language-Features/21-Module","title":"모듈"}}},{"node":{"fields":{"slug":"/Language-Features/23-Attribute-Decorator","title":"속성 (데코레이터)"}}},{"node":{"fields":{"slug":"/Language-Features/25-Reserved-Keyword","title":"예약된 키워드"}}},{"node":{"fields":{"slug":"/Language-Features/07-Object","title":"객체"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/02-Shared-Data-Types","title":"데이터 타입 공유"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/03-External-Bind-to-Any-JS-Library","title":"External (자바스크립트 라이브러리 바인딩)"}}},{"node":{"fields":{"slug":"/Language-Features/24-Unboxed","title":"언박싱"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/07-Bind-to-Global-JS-Values","title":"Bind to Global JS Values"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/01-Embed-Raw-JavaScript","title":"Embed Raw JavaScript"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/08-JSON","title":"JSON"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/05-Bind-to-JS-Function","title":"Bind to JS Function"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/06-Import-from-Export-to-JS","title":"Import from / Export to JS"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/09-Inlining-Constants","title":"Inlining Constants"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/10-Use-Illegal-Identifier-Names","title":"Use Illegal Identifier Names"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/12-Browser-Support-Polyfills","title":"Browser Support & Polyfills"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/11-Generate-Converters-Helpers","title":"인터롭 코드 자동 생성하기"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/13-Interop-Cheatsheet","title":"Interop Cheatsheet"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/11-Generate-Converters-Helpers/01-@deriving(accessors)","title":"@deriving(accessor)"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/11-Generate-Converters-Helpers/02-@deriving(jsConverter)","title":"@deriving(jsConverter)"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/11-Generate-Converters-Helpers/03-@deriving(abstract)","title":"@deriving(abstract)"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/11-Generate-Converters-Helpers/04-@obj","title":"@obj"}}},{"node":{"fields":{"slug":"/Guides/01-Converting-from-JS","title":"자바스크립트 파일을 변환하기"}}},{"node":{"fields":{"slug":"/Guides/02-Libraries","title":"Libraries"}}},{"node":{"fields":{"slug":"/Extra/01-Newcomer-Examples","title":"초보자를 위한 예제"}}},{"node":{"fields":{"slug":"/Extra/02-Project-Structure","title":"Project Structure"}}},{"node":{"fields":{"slug":"/Extra/03-FAQ","title":"자주 묻는 질문"}}},{"node":{"fields":{"slug":"/Build-System/03-Configuration-Schema","title":"Configuration Schema"}}},{"node":{"fields":{"slug":"/Build-System/04-Interop-with-JS-Build-Systems","title":"Interop with JS Build Systems"}}},{"node":{"fields":{"slug":"/Build-System/01-Overview","title":"Build System Overview"}}},{"node":{"fields":{"slug":"/Build-System/05-Performance","title":"Performance"}}},{"node":{"fields":{"slug":"/Build-System/02-Configuration","title":"Configuration"}}},{"node":{"fields":{"slug":"/ReScript-React/02-Main-Concepts/03-Components-and-Props","title":"컴포넌트와 Props"}}},{"node":{"fields":{"slug":"/ReScript-React/02-Main-Concepts/01-Elements-and-JSX","title":"엘레멘트와 JSX"}}}]}},"pageContext":{"id":"21f2ce49-a242-5cd2-9de0-d19aa353564d"}},"staticQueryHashes":["2619113677","2619113677","3706406642","3706406642","417421954","417421954"]}