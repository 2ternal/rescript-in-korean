{"componentChunkName":"component---src-templates-docs-js","path":"/ReScript-React/03-Hooks-and-State-Management/07-Build-A-Custom-Hook","result":{"data":{"site":{"siteMetadata":{"title":"ReScript in Korean","docsLocation":"https://github.com/green-labs/rescript-in-korean/tree/main/content"}},"mdx":{"fields":{"id":"674c7e31-dcbe-5085-b912-c5e561724978","title":"커스텀 훅 만들기","slug":"/ReScript-React/03-Hooks-and-State-Management/07-Build-A-Custom-Hook"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"커스텀 훅 만들기\",\n  \"metaTitle\": \"07-커스텀 훅 만들기(Build A Custom Hook)\",\n  \"metaDescription\": \"How to build your own hooks in ReScript & React\",\n  \"canonical\": \"https://rescript-lang.org/docs/react/latest/hooks-custom\",\n  \"sourceUrl\": \"https://rescript-lang.org/docs/react/latest/hooks-custom\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"React comes with a few fundamental hooks out-of-the-box, such as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.useState\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.useEffect\"), \". Here you will learn how to build your own, higher-level hooks for your React use-cases.\"), mdx(\"h2\", null, \"\\uC65C \\uCEE4\\uC2A4\\uD140 \\uD6C5\\uC744 \\uC4F0\\uC8E0?\"), mdx(\"p\", null, \"Custom hooks let you extract existing component logic into reusable, separate functions.\"), mdx(\"p\", null, \"Let's go back to a previous example from our \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"./hooks-effect\"\n  }), \"React.useEffect section\"), \" where we built a component for a chat application that displays a message, indicating whether a friend is online or offline:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\",\n    \"metastring\": \"{16-31}\",\n    \"{16-31}\": true\n  }), \"// FriendStatus.res\\n\\nmodule ChatAPI = {\\n  // Imaginary globally available ChatAPI for demo purposes\\n  type status = { isOnline: bool };\\n  @bs.val external subscribeToFriendStatus: (string, status => unit) => unit = \\\"subscribeToFriendStatus\\\";\\n  @bs.val external unsubscribeFromFriendStatus: (string, status => unit) => unit = \\\"unsubscribeFromFriendStatus\\\";\\n}\\n\\ntype state = Offline | Loading | Online;\\n\\n@react.component\\nlet make = (~friendId: string) => {\\n  let (state, setState) = React.useState(_ => Offline)\\n\\n  React.useEffect(() => {\\n    let handleStatusChange = (status) => {\\n      setState(_ => {\\n        status.ChatAPI.isOnline ? Online : Offline\\n      })\\n    }\\n\\n    ChatAPI.subscribeToFriendStatus(friendId, handleStatusChange);\\n    setState(_ => Loading);\\n\\n    let cleanup = () => {\\n      ChatAPI.unsubscribeFromFriendStatus(friendId, handleStatusChange)\\n    }\\n\\n    Some(cleanup)\\n  })\\n\\n  let text = switch(state) {\\n    | Offline => friendId ++ \\\" is offline\\\"\\n    | Online => friendId ++ \\\" is online\\\"\\n    | Loading => \\\"loading...\\\"\\n  }\\n\\n  <div>\\n    {React.string(text)}\\n  </div>\\n}\\n\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"function FriendStatus(Props) {\\n  var friendId = Props.friendId;\\n  var match = React.useState(function() {\\n    return /* Offline */ 0;\\n  });\\n  var setState = match[1];\\n  React.useEffect(function() {\\n    var handleStatusChange = function(status) {\\n      return Curry._1(setState, function(param) {\\n        if (status.isOnline) {\\n          return /* Online */ 2;\\n        } else {\\n          return /* Offline */ 0;\\n        }\\n      });\\n    };\\n    subscribeToFriendStatus(friendId, handleStatusChange);\\n    Curry._1(setState, function(param) {\\n      return /* Loading */ 1;\\n    });\\n    return function(param) {\\n      unsubscribeFromFriendStatus(friendId, handleStatusChange);\\n    };\\n  });\\n  var text;\\n  switch (match[0]) {\\n    case /* Offline */ 0:\\n      text = friendId + ' is offline';\\n      break;\\n    case /* Loading */ 1:\\n      text = 'loading...';\\n      break;\\n    case /* Online */ 2:\\n      text = friendId + ' is online';\\n      break;\\n  }\\n  return React.createElement('div', undefined, text);\\n}\\n\")), mdx(\"p\", null, \"Now let\\u2019s say that our chat application also has a contact list, and we want to render names of online users with a green color. We could copy and paste similar logic above into our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FriendListItem\"), \" component but it wouldn\\u2019t be ideal:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\",\n    \"metastring\": \"{15-30}\",\n    \"{15-30}\": true\n  }), \"// FriendListItem.res\\ntype state = Offline | Loading | Online;\\n\\n// module ChatAPI = {...}\\n\\ntype friend = {\\n  id: string,\\n  name: string\\n};\\n\\n@react.component\\nlet make = (~friend: friend) => {\\n  let (state, setState) = React.useState(_ => Offline)\\n\\n  React.useEffect(() => {\\n    let handleStatusChange = (status) => {\\n      setState(_ => {\\n        status.ChatAPI.isOnline ? Online : Offline\\n      })\\n    }\\n\\n    ChatAPI.subscribeToFriendStatus(friend.id, handleStatusChange);\\n    setState(_ => Loading);\\n\\n    let cleanup = () => {\\n      ChatAPI.unsubscribeFromFriendStatus(friend.id, handleStatusChange)\\n    }\\n\\n    Some(cleanup)\\n  })\\n\\n  let color = switch(state) {\\n    | Offline => \\\"red\\\"\\n    | Online => \\\"green\\\"\\n    | Loading => \\\"grey\\\"\\n  }\\n\\n  <li style={ReactDOMStyle.make(~color,())}>\\n      {React.string(friend.name)}\\n  </li>\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"function FriendListItem(Props) {\\n  var friend = Props.friend;\\n  var match = React.useState(function() {\\n    return /* Offline */ 0;\\n  });\\n  var setState = match[1];\\n  React.useEffect(function() {\\n    var handleStatusChange = function(status) {\\n      return Curry._1(setState, function(param) {\\n        if (status.isOnline) {\\n          return /* Online */ 2;\\n        } else {\\n          return /* Offline */ 0;\\n        }\\n      });\\n    };\\n    subscribeToFriendStatus(friend.id, handleStatusChange);\\n    Curry._1(setState, function(param) {\\n      return /* Loading */ 1;\\n    });\\n    return function(param) {\\n      unsubscribeFromFriendStatus(friend.id, handleStatusChange);\\n    };\\n  });\\n  var color;\\n  switch (match[0]) {\\n    case /* Offline */ 0:\\n      color = 'red';\\n      break;\\n    case /* Loading */ 1:\\n      color = 'grey';\\n      break;\\n    case /* Online */ 2:\\n      color = 'green';\\n      break;\\n  }\\n  return React.createElement(\\n    'li',\\n    {\\n      style: {\\n        color: color,\\n      },\\n    },\\n    friend.name\\n  );\\n}\\n\")), mdx(\"p\", null, \"Instead, we\\u2019d like to share this logic between \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FriendStatus\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FriendListItem\"), \".\"), mdx(\"p\", null, \"Traditionally in React, we\\u2019ve had two popular ways to share stateful logic between components: render props and higher-order components. We will now look at how Hooks solve many of the same problems without forcing you to add more components to the tree.\"), mdx(\"h2\", null, \"Extracting a Custom Hook\"), mdx(\"p\", null, \"Usually when we want to share logic between two functions, we extract it to a third function. Both components and Hooks are functions, so this works for them too!\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"A custom Hook is a function whose name starts with \\u201Duse\\u201D and that may call other Hooks.\"), \" For example, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useFriendStatus\"), \" below is our first custom Hook (we create a new file \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FriendStatusHook.res\"), \" to encapsulate the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"state\"), \" type as well):\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"// FriendStatusHook.res\\n\\n// module ChatAPI {...}\\n\\ntype state = Offline | Loading | Online\\n\\nlet useFriendStatus = (friendId: string): state => {\\n  let (state, setState) = React.useState(_ => Offline)\\n\\n  React.useEffect(() => {\\n    let handleStatusChange = status => {\\n      setState(_ => {\\n        status.ChatAPI.isOnline ? Online : Offline\\n      })\\n    }\\n\\n    ChatAPI.subscribeToFriendStatus(friendId, handleStatusChange)\\n    setState(_ => Loading)\\n\\n    let cleanup = () => {\\n      ChatAPI.unsubscribeFromFriendStatus(friendId, handleStatusChange)\\n    }\\n\\n    Some(cleanup)\\n  })\\n\\n  state\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"function useFriendStatus(friendId) {\\n  var match = React.useState(function() {\\n    return /* Offline */ 0;\\n  });\\n  var setState = match[1];\\n  React.useEffect(function() {\\n    var handleStatusChange = function(status) {\\n      return Curry._1(setState, function(param) {\\n        if (status.isOnline) {\\n          return /* Online */ 2;\\n        } else {\\n          return /* Offline */ 0;\\n        }\\n      });\\n    };\\n    subscribeToFriendStatus(friendId, handleStatusChange);\\n    Curry._1(setState, function(param) {\\n      return /* Loading */ 1;\\n    });\\n    return function(param) {\\n      unsubscribeFromFriendStatus(friendId, handleStatusChange);\\n    };\\n  });\\n  return match[0];\\n}\\n\")), mdx(\"p\", null, \"There\\u2019s nothing new inside of it \\u2014 the logic is copied from the components above. Just like in a component, make sure to only call other Hooks unconditionally at the top level of your custom Hook.\"), mdx(\"p\", null, \"Unlike a React component, a custom Hook doesn\\u2019t need to have a specific signature. We can decide what it takes as arguments, and what, if anything, it should return. In other words, it\\u2019s just like a normal function. Its name should always start with use so that you can tell at a glance that the rules of Hooks apply to it.\"), mdx(\"p\", null, \"The purpose of our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useFriendStatus\"), \" Hook is to subscribe us to a friend\\u2019s status. This is why it takes \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"friendId\"), \" as an argument, and returns the online state like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Online\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Offline\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Loading\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"let useFriendStatus = (friendId: string): status {\\n  let (state, setState) = React.useState(_ => Offline);\\n\\n  // ...\\n\\n  state\\n}\\n\")), mdx(\"p\", null, \"Now let\\u2019s use our custom Hook.\"), mdx(\"h2\", null, \"\\uCEE4\\uC2A4\\uD140 \\uD6C5 \\uC0AC\\uC6A9\\uD558\\uAE30\"), mdx(\"p\", null, \"In the beginning, our stated goal was to remove the duplicated logic from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FriendStatus\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FriendListItem\"), \" components. Both of them want to know the online state of a friend.\"), mdx(\"p\", null, \"Now that we\\u2019ve extracted this logic to a useFriendStatus hook, we can just use it:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\",\n    \"metastring\": \"{6}\",\n    \"{6}\": true\n  }), \"// FriendStatus.res\\ntype friend = { id: string };\\n\\n@react.component\\nlet make = (~friend: friend) => {\\n  let onlineState = FriendStatusHook.useFriendStatus(friend.id);\\n\\n  let status = switch(onlineState) {\\n    | FriendStatusHook.Online => \\\"Online\\\"\\n    | Loading => \\\"Loading\\\"\\n    | Offline => \\\"Offline\\\"\\n  }\\n\\n  React.string(status);\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"function FriendStatus(Props) {\\n  var friend = Props.friend;\\n  var onlineState = useFriendStatus(friend.id);\\n  var color;\\n  switch (onlineState) {\\n    case /* Offline */ 0:\\n      color = 'red';\\n      break;\\n    case /* Loading */ 1:\\n      color = 'grey';\\n      break;\\n    case /* Online */ 2:\\n      color = 'green';\\n      break;\\n  }\\n  return React.createElement(\\n    'li',\\n    {\\n      style: {\\n        color: color,\\n      },\\n    },\\n    friend.name\\n  );\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\",\n    \"metastring\": \"{4}\",\n    \"{4}\": true\n  }), \"// FriendListItem.res\\n@react.component\\nlet make = (~friend: friend) => {\\n  let onlineState = FriendStatusHook.useFriendStatus(friend.id);\\n\\n  let color = switch(onlineState) {\\n    | Offline => \\\"red\\\"\\n    | Online => \\\"green\\\"\\n    | Loading => \\\"grey\\\"\\n  }\\n\\n  <li style={ReactDOMStyle.make(~color,())}>\\n      {React.string(friend.name)}\\n  </li>\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"function FriendListItem(Props) {\\n  var friend = Props.friend;\\n  var onlineState = useFriendStatus(friend.id);\\n  var color;\\n  switch (onlineState) {\\n    case /* Offline */ 0:\\n      color = 'red';\\n      break;\\n    case /* Loading */ 1:\\n      color = 'grey';\\n      break;\\n    case /* Online */ 2:\\n      color = 'green';\\n      break;\\n  }\\n  return React.createElement(\\n    'li',\\n    {\\n      style: {\\n        color: color,\\n      },\\n    },\\n    friend.name\\n  );\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Is this code equivalent to the original examples?\"), \" Yes, it works in exactly the same way. If you look closely, you\\u2019ll notice we didn\\u2019t make any changes to the behavior. All we did was to extract some common code between two functions into a separate function. Custom Hooks are a convention that naturally follows from the design of Hooks, rather than a React feature.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Do I have to name my custom Hooks starting with \\u201Cuse\\u201D?\"), \" Please do. This convention is very important. Without it, we wouldn\\u2019t be able to automatically check for violations of rules of Hooks because we couldn\\u2019t tell if a certain function contains calls to Hooks inside of it.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Do two components using the same Hook share state?\"), \" No. Custom Hooks are a mechanism to reuse stateful logic (such as setting up a subscription and remembering the current value), but every time you use a custom Hook, all state and effects inside of it are fully isolated.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"How does a custom Hook get isolated state?\"), \" Each call to a Hook gets isolated state. Because we call useFriendStatus directly, from React\\u2019s point of view our component just calls useState and useEffect. And as we learned earlier, we can call useState and useEffect many times in one component, and they will be completely independent.\"), mdx(\"h3\", null, \"\\uD301: \\uD6C5\\uB07C\\uB9AC \\uC815\\uBCF4 \\uB118\\uAE30\\uAE30\"), mdx(\"p\", null, \"Since Hooks are functions, we can pass information between them.\"), mdx(\"p\", null, \"To illustrate this, we\\u2019ll use another component from our hypothetical chat example. This is a chat message recipient picker that displays whether the currently selected friend is online:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\",\n    \"metastring\": \"{11,12,14-18,22}\",\n    \"{11,12,14-18,22}\": true\n  }), \"type friend = {id: string, name: string}\\n\\nlet friendList = [\\n  {id: \\\"1\\\", name: \\\"Phoebe\\\"},\\n  {id: \\\"2\\\", name: \\\"Rachel\\\"},\\n  {id: \\\"3\\\", name: \\\"Ross\\\"},\\n]\\n\\n@react.component\\nlet make = () => {\\n  let (recipientId, setRecipientId) = React.useState(_ => \\\"1\\\")\\n  let recipientOnlineState = FriendStatusHook.useFriendStatus(recipientId)\\n\\n  let color = switch recipientOnlineState {\\n  | FriendStatusHook.Offline => Circle.Red\\n  | Online => Green\\n  | Loading => Grey\\n  }\\n\\n  let onChange = evt => {\\n    let value = ReactEvent.Form.target(evt)[\\\"value\\\"]\\n    setRecipientId(value)\\n  }\\n\\n  let friends = Belt.Array.map(friendList, friend => {\\n    <option key={friend.id} value={friend.id}>\\n      {React.string(friend.name)}\\n    </option>\\n  })\\n\\n  <>\\n    <Circle color />\\n    <select value={recipientId} onChange>\\n      {React.array(friends)}\\n    </select>\\n  </>\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"var friendList = [\\n  {\\n    id: '1',\\n    name: 'Phoebe',\\n  },\\n  {\\n    id: '2',\\n    name: 'Rachel',\\n  },\\n  {\\n    id: '3',\\n    name: 'Ross',\\n  },\\n];\\n\\nfunction Playground(Props) {\\n  var match = React.useState(function() {\\n    return '1';\\n  });\\n  var setRecipientId = match[1];\\n  var recipientId = match[0];\\n  var recipientOnlineState = useFriendStatus(recipientId);\\n  var color;\\n  switch (recipientOnlineState) {\\n    case /* Offline */ 0:\\n      color = /* Red */ 0;\\n      break;\\n    case /* Loading */ 1:\\n      color = /* Grey */ 2;\\n      break;\\n    case /* Online */ 2:\\n      color = /* Green */ 1;\\n      break;\\n  }\\n  var onChange = function(evt) {\\n    return Curry._1(setRecipientId, evt.target.value);\\n  };\\n  var friends = Belt_Array.map(friendList, function(friend) {\\n    return React.createElement(\\n      'option',\\n      {\\n        key: friend.id,\\n        value: friend.id,\\n      },\\n      friend.name\\n    );\\n  });\\n  return React.createElement(\\n    React.Fragment,\\n    undefined,\\n    React.createElement(Playground$Circle, {\\n      color: color,\\n    }),\\n    React.createElement(\\n      'select',\\n      {\\n        value: recipientId,\\n        onChange: onChange,\\n      },\\n      friends\\n    )\\n  );\\n}\\n\")), mdx(\"p\", null, \"We keep the currently chosen friend ID in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"recipientId\"), \" state variable, and update it if the user chooses a different friend in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<select>\"), \" picker.\"), mdx(\"p\", null, \"Because the useState Hook call gives us the latest value of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"recipientId\"), \" state variable, we can pass it to our custom \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FriendStatusHook.useFriendStatus\"), \" Hook as an argument:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"let (recipientId, setRecipientId) = React.useState(_ => \\\"1\\\")\\nlet recipientOnlineState = FriendStatusHook.useFriendStatus(recipientId)\\n\")), mdx(\"p\", null, \"This lets us know whether the currently selected friend is online. If we pick a different friend and update the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"recipientId\"), \" state variable, our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FriendStatus.useFriendStatus\"), \" Hook will unsubscribe from the previously selected friend, and subscribe to the status of the newly selected one.\"), mdx(\"h2\", null, \"\\uC0C1\\uC0C1\\uB825\\uC744 \\uBC1C\\uD718 \\uD574\\uBCF4\\uC138\\uC694\"), mdx(\"p\", null, \"Custom Hooks offer the flexibility of sharing logic. You can write custom Hooks that cover a wide range of use cases like form handling, animation, declarative subscriptions, timers, and probably many more we haven\\u2019t considered. What\\u2019s more, you can build Hooks that are just as easy to use as React\\u2019s built-in features.\"), mdx(\"p\", null, \"Try to resist adding abstraction too early. It's pretty common that components grow pretty big when there is enough stateful logic handling involved. This is normal \\u2014 don\\u2019t feel like you have to immediately split it into Hooks. But we also encourage you to start spotting cases where a custom Hook could hide complex logic behind a simple interface, or help untangle a messy component.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#왜-커스텀-훅을-쓰죠","title":"왜 커스텀 훅을 쓰죠?"},{"url":"#extracting-a-custom-hook","title":"Extracting a Custom Hook"},{"url":"#커스텀-훅-사용하기","title":"커스텀 훅 사용하기","items":[{"url":"#팁-훅끼리-정보-넘기기","title":"팁: 훅끼리 정보 넘기기"}]},{"url":"#상상력을-발휘-해보세요","title":"상상력을 발휘 해보세요"}]},"parent":{"__typename":"File","relativePath":"ReScript-React/03-Hooks-and-State-Management/07-Build-A-Custom-Hook.mdx"},"frontmatter":{"metaTitle":"07-커스텀 훅 만들기(Build A Custom Hook)","metaDescription":"How to build your own hooks in ReScript & React","sourceUrl":"https://rescript-lang.org/docs/react/latest/hooks-custom","canonical":"https://rescript-lang.org/docs/react/latest/hooks-custom"}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/Build-System","title":"빌드 시스템"}}},{"node":{"fields":{"slug":"/Extra","title":"그 외"}}},{"node":{"fields":{"slug":"/Guides","title":"가이드"}}},{"node":{"fields":{"slug":"/JavaScript-Interop","title":"자바스크립트 인터롭"}}},{"node":{"fields":{"slug":"/Language-Features","title":"언어적인 특징"}}},{"node":{"fields":{"slug":"/Overview","title":"개요"}}},{"node":{"fields":{"slug":"/ReScript-React","title":"ReScript React"}}},{"node":{"fields":{"slug":"/","title":"ReScript in Korean"}}},{"node":{"fields":{"slug":"/Build-System/01-Overview","title":"Build System Overview"}}},{"node":{"fields":{"slug":"/Build-System/02-Configuration","title":"Configuration"}}},{"node":{"fields":{"slug":"/Build-System/03-Configuration-Schema","title":"Configuration Schema"}}},{"node":{"fields":{"slug":"/Build-System/04-Interop-with-JS-Build-Systems","title":"Interop with JS Build Systems"}}},{"node":{"fields":{"slug":"/Build-System/05-Performance","title":"Performance"}}},{"node":{"fields":{"slug":"/Extra/01-Newcomer-Examples","title":"초보자를 위한 예제"}}},{"node":{"fields":{"slug":"/Extra/02-Project-Structure","title":"Project Structure"}}},{"node":{"fields":{"slug":"/Extra/03-FAQ","title":"자주 묻는 질문"}}},{"node":{"fields":{"slug":"/Guides/01-Converting-from-JS","title":"자바스크립트 파일을 변환하기"}}},{"node":{"fields":{"slug":"/Guides/02-Libraries","title":"Libraries"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/04-Bind-to-JS-Object","title":"자바스크립트 객체에 바인딩하기"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/05-Bind-to-JS-Function","title":"Bind to JS Function"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/06-Import-from-Export-to-JS","title":"Import from / Export to JS"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/07-Bind-to-Global-JS-Values","title":"Bind to Global JS Values"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/08-JSON","title":"JSON"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/09-Inlining-Constants","title":"Inlining Constants"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/10-Use-Illegal-Identifier-Names","title":"Use Illegal Identifier Names"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/11-Generate-Converters-Helpers","title":"인터롭 코드 자동 생성하기"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/12-Browser-Support-Polyfills","title":"Browser Support & Polyfills"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/13-Interop-Cheatsheet","title":"Interop Cheatsheet"}}},{"node":{"fields":{"slug":"/Language-Features/01-Overview","title":"개요"}}},{"node":{"fields":{"slug":"/Language-Features/02-Let-Binding","title":"Let Binding"}}},{"node":{"fields":{"slug":"/Language-Features/03-Type","title":"타입"}}},{"node":{"fields":{"slug":"/Language-Features/04-Primitive-Types","title":"원시 타입"}}},{"node":{"fields":{"slug":"/Language-Features/05-Tuple","title":"튜플"}}},{"node":{"fields":{"slug":"/Language-Features/06-Record","title":"레코드"}}},{"node":{"fields":{"slug":"/Language-Features/07-Object","title":"객체"}}},{"node":{"fields":{"slug":"/Language-Features/08-Variant","title":"배리언트"}}},{"node":{"fields":{"slug":"/Language-Features/09-Polymorphic-Variant","title":"Polymorphic Variant"}}},{"node":{"fields":{"slug":"/Language-Features/10-Null-Undefined-and-Option","title":"Null, Undefined 그리고 Option"}}},{"node":{"fields":{"slug":"/Language-Features/11-Array-List","title":"배열과 리스트"}}},{"node":{"fields":{"slug":"/Language-Features/12-Function","title":"함수"}}},{"node":{"fields":{"slug":"/Language-Features/13-Control-Flow","title":"제어 흐름"}}},{"node":{"fields":{"slug":"/Language-Features/14-Pipe","title":"파이프"}}},{"node":{"fields":{"slug":"/Language-Features/15-Pattern-Matching-Destructuring","title":"패턴 매칭 / 구조분해"}}},{"node":{"fields":{"slug":"/Language-Features/16-Mutation","title":"가변"}}},{"node":{"fields":{"slug":"/Language-Features/17-JSX","title":"JSX"}}},{"node":{"fields":{"slug":"/Language-Features/18-Exception","title":"예외"}}},{"node":{"fields":{"slug":"/Language-Features/19-Lazy-Value","title":"Lazy Value"}}},{"node":{"fields":{"slug":"/Language-Features/20-Async-Promise","title":"Async & Promise"}}},{"node":{"fields":{"slug":"/Language-Features/21-Module","title":"모듈"}}},{"node":{"fields":{"slug":"/Language-Features/22-Import-Export","title":"Import & Export"}}},{"node":{"fields":{"slug":"/Language-Features/23-Attribute-Decorator","title":"속성 (데코레이터)"}}},{"node":{"fields":{"slug":"/Language-Features/24-Unboxed","title":"언박싱"}}},{"node":{"fields":{"slug":"/Language-Features/25-Reserved-Keyword","title":"예약된 키워드"}}},{"node":{"fields":{"slug":"/Overview/01-Introduction","title":"소개"}}},{"node":{"fields":{"slug":"/Overview/02-Installation","title":"설치"}}},{"node":{"fields":{"slug":"/Overview/03-EditorPlugins","title":"편집기 플러그인"}}},{"node":{"fields":{"slug":"/Overview/04-Migrate-to-ReScript-Syntax","title":"리스크립트 문법으로 변경하기"}}},{"node":{"fields":{"slug":"/Overview/05-Try","title":"CLI로 직접 해보기"}}},{"node":{"fields":{"slug":"/ReScript-React/01-Overview","title":"개요"}}},{"node":{"fields":{"slug":"/ReScript-React/02-Main-Concepts","title":"메인 컨셉"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management","title":"리액트 훅과 상태 관리"}}},{"node":{"fields":{"slug":"/ReScript-React/04-Guides","title":"가이드"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/11-Generate-Converters-Helpers/01-@deriving(accessors)","title":"@deriving(accessor)"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/11-Generate-Converters-Helpers/02-@deriving(jsConverter)","title":"@deriving(jsConverter)"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/11-Generate-Converters-Helpers/03-@deriving(abstract)","title":"@deriving(abstract)"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/11-Generate-Converters-Helpers/04-@obj","title":"@obj"}}},{"node":{"fields":{"slug":"/ReScript-React/01-Overview/01-Introduction","title":"소개"}}},{"node":{"fields":{"slug":"/ReScript-React/01-Overview/02-Installation","title":"설치"}}},{"node":{"fields":{"slug":"/ReScript-React/02-Main-Concepts/01-Elements-and-JSX","title":"엘레멘트와 JSX"}}},{"node":{"fields":{"slug":"/ReScript-React/02-Main-Concepts/02-Rendering-Elements","title":"엘레멘트 렌더링하기"}}},{"node":{"fields":{"slug":"/ReScript-React/02-Main-Concepts/03-Components-and-Props","title":"컴포넌트와 Props"}}},{"node":{"fields":{"slug":"/ReScript-React/02-Main-Concepts/04-Arrays-and-Keys","title":"배열과 키"}}},{"node":{"fields":{"slug":"/ReScript-React/02-Main-Concepts/05-Refs-and-the-DOM","title":"Refs와 DOM"}}},{"node":{"fields":{"slug":"/ReScript-React/02-Main-Concepts/06-Context","title":"컨텍스트"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/03-External-Bind-to-Any-JS-Library","title":"External (자바스크립트 라이브러리 바인딩)"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/02-Shared-Data-Types","title":"데이터 타입 공유"}}},{"node":{"fields":{"slug":"/JavaScript-Interop/01-Embed-Raw-JavaScript","title":"Embed Raw JavaScript"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management/01-Hooks-and-State-Management-Overview","title":"리액트 훅과 상태 관리 개요"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management/02-useEffect","title":"useEffect"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management/03-useState","title":"useState"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management/04-useReducer","title":"useReducer"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management/05-useContext","title":"useContext"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management/06-useRef","title":"useRef"}}},{"node":{"fields":{"slug":"/ReScript-React/03-Hooks-and-State-Management/07-Build-A-Custom-Hook","title":"커스텀 훅 만들기"}}},{"node":{"fields":{"slug":"/ReScript-React/04-Guides/01-Beyond-JSX","title":"JSX를 넘어서"}}},{"node":{"fields":{"slug":"/ReScript-React/04-Guides/02-Forwarding-Refs","title":"Ref 포워딩하기"}}}]}},"pageContext":{"id":"674c7e31-dcbe-5085-b912-c5e561724978"}},"staticQueryHashes":["2619113677","2619113677","3706406642","3706406642","417421954","417421954"]}